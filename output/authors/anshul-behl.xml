<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Ansible Collaborative (Posts by Anshul Behl)</title><link>https://ansible.com/</link><description></description><atom:link href="https://ansible.com/authors/anshul-behl.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2024 &lt;a href="mailto:website@ansible.community"&gt;Ansible Collaborative, et al&lt;/a&gt; </copyright><lastBuildDate>Thu, 21 Mar 2024 14:38:23 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>The anatomy of automation execution environments</title><link>https://ansible.com/blog/the-anatomy-of-automation-execution-environments/</link><dc:creator>Anshul Behl</dc:creator><description>&lt;h2&gt;The anatomy of automation execution environments&lt;/h2&gt;
&lt;p&gt;Red Hat Ansible Automation Platform 2 introduced  major architectural
changes, like automation mesh and automation execution environments,
that help extend Ansible automation across your organization in a
flexible manner, providing a single solution to all your organizational
and hybrid cloud automation needs.&lt;/p&gt;
&lt;p&gt;Automation execution environments are container images that act as
Ansible runtimes for automation controller jobs. Ansible Automation
Platform also includes a command-line tool called
ansible-builder(execution environment builder)that lets you create
automation execution environments by specifying Ansible Content
Collections and Python dependencies.&lt;/p&gt;
&lt;p&gt;In general, an automation execution environment includes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A version of Python.&lt;/li&gt;
&lt;li&gt;A version of ansible-core.&lt;/li&gt;
&lt;li&gt;Python modules/dependencies.&lt;/li&gt;
&lt;li&gt;Ansible Content Collections (optional).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="diagram of an execution environment" src="https://ansible.com/images/posts/archive/execution-environment-ubi.png"&gt;&lt;/p&gt;
&lt;p&gt;In this blog, I will take you through the inner workings of
ansible-builder and &lt;strong&gt;how&lt;/strong&gt; all the above requirements are packaged
inside automation execution environments and delivered as part of
Ansible Automation Platform.&lt;/p&gt;
&lt;h2&gt;A tale of two ansible-builder packages&lt;/h2&gt;
&lt;p&gt;As all projects in Red Hat, ansible-builder follows an open development
model and an upstream-first approach. The upstream project for
&lt;a href="https://github.com/ansible/ansible-builder"&gt;ansible-builder&lt;/a&gt; is
distributed as a Python package, and then packaged into an RPM for
Ansible Automation Platform downstream. This
also means that there are different ways to install the upstream package
and the downstream ansible-builder.&lt;/p&gt;
&lt;p&gt;NOTE: To get the downstream packages, you must subscribe to Ansible
Automation Platform repos from Red Hat.&lt;/p&gt;
&lt;p&gt;Upstream:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;pip3&lt;span class="w"&gt; &lt;/span&gt;install&lt;span class="w"&gt; &lt;/span&gt;ansible-builder
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Downstream: &lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;dnf&lt;span class="w"&gt; &lt;/span&gt;install&lt;span class="w"&gt; &lt;/span&gt;ansible-builder
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This has sometimes led to confusions among users, as customers of
Ansible Automation Platform can also install the Python package for
free. There are minor differences between both upstream and downstream
packages that you should understand before diving deeper into building
automation execution environments.&lt;/p&gt;
&lt;p&gt;As mentioned earlier, automation execution environments are container
images that act as Ansible runtimes and ansible-builder is quite similar
to generally available container engines such as Podman and Docker. So
like any other container engine, the concept of building an image starts
with a base image; that is where the upstream and downstream packages
for ansible-builder differ. The base images used in upstream
ansible-builder (Python package) as predefined constants are as follows:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="nv"&gt;EE_BASE_IMAGE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'quay.io/ansible/ansible-runner:latest'&lt;/span&gt;
&lt;span class="nv"&gt;EE_BUILDER_IMAGE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'quay.io/ansible/ansible-builder:latest'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Base images in the downstream package are as follows:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="nv"&gt;EE_BASE_IMAGE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'registry.redhat.io/ansible-automation-platform-22/ee-minimal-rhel8:latest'&lt;/span&gt;
&lt;span class="nv"&gt;EE_BUILDER_IMAGE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'registry.redhat.io/ansible-automation-platform-22/ansible-builder-rhel8:latest'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Upstream base images are available through Red Hat Quay.io, while the
downstream ones come from Red Hat Ecosystem Catalog(registry.redhat.io),
which requires authentication with a Red Hat account. The other
difference in these images is that upstream ones use CentOS image as the
base image while the downstream ones use Red Hat Universal Base Image
(UBI). UBI offers greater reliability, security, and performance for
official Red Hat container images compared with CentOS images.&lt;/p&gt;
&lt;p&gt;One commonality for the upstream and downstream packages is that they
both allow image configuration through an automation execution
environment specification file called execution-environment.yml.&lt;/p&gt;
&lt;p&gt;Whether you are an Ansible Automation Platform customer or a community
user of ansible-builder, you can use UBI images as base images or the
CentOS images for your automation execution environments based on the
package or by  passing a different set of base images to your automation
execution environment specification file.&lt;/p&gt;
&lt;h2&gt;Why does the ansible-builder package have two base images?&lt;/h2&gt;
&lt;p&gt;Continuing from the previous section that introduce the upstream and
downstream base images for ansible-builder, there are two arguments that
specify which images to use:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;EE_BASE_IMAGE&lt;/code&gt; build argument specifies the parent image for the
    automation execution environment.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;EE_BUILDER_IMAGE&lt;/code&gt; build argument specifies the image used for
    compiling type tasks.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For most container images, you generally only need one base image on top
of which you add different instructions, also known as build steps, to
create your final container image.&lt;/p&gt;
&lt;p&gt;However, the base automation execution environment (ee-minimal) is built
using the multi-stage build concept of containers. The &lt;code&gt;EE_BUILDER_IMAGE&lt;/code&gt;
build argument serves as the intermediary step to install Collections
and build dependencies to keep the base image size as low as possible.&lt;/p&gt;
&lt;p&gt;Let's take an example: Suppose your Ansible Content Collection depends
on a Python package that needs to be compiled using python-dev package
(e.g. NumPy). Because python-dev is a compile time dependency, you don't
necessarily need it in the final package (you just need the NumPy
package). You wouldn't want to include python-dev in the final image to
keep the image size as low as possible. For this purpose, the
&lt;code&gt;EE_BUILDER_IMAGE&lt;/code&gt; is used to build dependencies and then copy over only
the package wheels needed for the final automation execution
environment.&lt;/p&gt;
&lt;h3&gt;Does this matter if I want to build a custom automation execution environment?&lt;/h3&gt;
&lt;p&gt;In most cases it doesn't matter. When you build your automation
execution environment using ansible-builder, you just need &lt;code&gt;EE_BASE_IMAGE&lt;/code&gt;
and not &lt;code&gt;EE_BUILDER_IMAGE&lt;/code&gt;. However, you should understand how a compile
time binary dependency is applied in the execution-environment
definition file called bindep.txt. For the above example, if you need to
install the NumPy Python package as a dependency for your Collection on
UBI8, you specify the bindep.txt and requirements.txt as follows:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="c1"&gt;# bindep.txt&lt;/span&gt;
python38-devel&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;compile&lt;span class="w"&gt; &lt;/span&gt;platform:rhel-8&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;#compile time dependency&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="c1"&gt;# requirements.txt&lt;/span&gt;
NumPy
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;There will be instances where the configuration in the automation
execution environment specification isn't reflected or errors occur when
you're building the automation execution environment. In these
instances, it's important to understand the role for the
EE_BUILDER_IMAGE. The next section explains this in more detail.&lt;/p&gt;
&lt;h2&gt;Automation execution environment design&lt;/h2&gt;
&lt;p&gt;&lt;img alt="diagram picture of automation execution environment design" src="https://ansible.com/images/posts/archive/execution-environment-diagram.png"&gt;&lt;/p&gt;
&lt;p&gt;The above diagram outlines how automation execution environments are
designed. I have mentioned the upstream image name and the downstream
counterparts in the same boxes.&lt;/p&gt;
&lt;p&gt;For reference, CentOS 8 and UBI8 (for downstream) serve as the base
images for the python-base container image, which acts as the image for
running python-based projects, hence it bundles a version of Python that
is supported by the ansible-core package (python 3.8 for reference).&lt;/p&gt;
&lt;p&gt;This python-base image serves as the base image for both the
python-builder image as well as the ansible-runner (ee-minimal
downstream) image. To summarize the purpose of python-builder and
ansible-builder images, they build Python projects such as ansible-core
and any Collections that are dependent on Python. For instance, if your
Collection relies on Python dependencies for which wheels need to be
built on the machine itself, they are built on the python-builder image.&lt;/p&gt;
&lt;p&gt;Finally, the ansible-runner (ee-minimal downstream) image includes a
version of the ansible-core package. The ansible-builder image works in
conjunction with this image to build Python wheels, so that the final
automation execution environment size is minimal by only keeping things
that are necessary to run your required automation. custom-ee1 and
custom-ee2 in the diagram represent any custom automation execution
environments that can be created using ansible-runner (ee-minimal
downstream) and the ansible-builder image.&lt;/p&gt;
&lt;h2&gt;Verifying your base images&lt;/h2&gt;
&lt;p&gt;To start building your custom automation execution environments, you
should first verify which &lt;code&gt;EE_BASE_IMAGE&lt;/code&gt; and &lt;code&gt;EE_BUILDER_IMAGE&lt;/code&gt; are used in
ansible-builder by default. To verify, first create an empty automation
execution environment definition file called execution-environment.yml&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;touch&lt;span class="w"&gt; &lt;/span&gt;execution-environment.yml
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Then create a build context from the empty definition file by running
this command in the same directory where you created the empty
definition file:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;ansible-builder&lt;span class="w"&gt; &lt;/span&gt;create
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This will create a context directory in your working directory which
includes a Containerfile. Opening the Containerfile shows which images
are set as the BASE and BUILDER images and tells you which
ansible-builder you are using, the upstream or the downstream one. For
instance, if you open the Containerfile created through the above
process and a pip install of ansible-builder, you see the following
content:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;ARG&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;EE_BASE_IMAGE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;quay.io/ansible/ansible-runner:latest
ARG&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;EE_BUILDER_IMAGE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;quay.io/ansible/ansible-builder:latest

FROM&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$EE_BASE_IMAGE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;as&lt;span class="w"&gt; &lt;/span&gt;galaxy
ARG&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;ANSIBLE_GALAXY_CLI_COLLECTION_OPTS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;
USER&lt;span class="w"&gt; &lt;/span&gt;root


FROM&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$EE_BUILDER_IMAGE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;as&lt;span class="w"&gt; &lt;/span&gt;builder

FROM&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$EE_BASE_IMAGE&lt;/span&gt;
USER&lt;span class="w"&gt; &lt;/span&gt;root
COPY&lt;span class="w"&gt; &lt;/span&gt;--from&lt;span class="o"&gt;=&lt;/span&gt;builder&lt;span class="w"&gt; &lt;/span&gt;/output/&lt;span class="w"&gt; &lt;/span&gt;/output/
RUN&lt;span class="w"&gt; &lt;/span&gt;/output/install-from-bindep&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;rm&lt;span class="w"&gt; &lt;/span&gt;-rf&lt;span class="w"&gt; &lt;/span&gt;/output/wheels
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In the first two lines you can observe that the images point to the
upstream images. If you do the same process on the downstream install of
ansible-builder, you find the downstream images in a similar
Containerfile.&lt;/p&gt;
&lt;h2&gt;Using the ansible-builder context&lt;/h2&gt;
&lt;p&gt;The context building is an important aspect of ansible-builder. You can
use the context to change the Containerfile and customize your
automation execution environments to your needs. You can use this
context and the knowledge of multi-stage builds using BUILDER and BASE
images to build an automation execution environment in a disconnected
environment. The following shows an execution-environment definition
that pulls the BUILDER and BASE images from a private automation hub
instance:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="gh"&gt;#&lt;/span&gt; cat execution-environment.yml
---
version: 1
build_arg_defaults:
  EE_BASE_IMAGE: 'automation-hub.demolab.local/ansible-automation-platform-22/ee-minimal-rhel8:latest'
  EE_BUILDER_IMAGE: 'automation-hub.demolab.local/ansible-automation-platform-22/ansible-builder-rhel8:latest'

dependencies:
  python: requirements.txt
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And the contents of the requirements.txt file are as follows:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="c1"&gt;# cat requirements.txt&lt;/span&gt;
&lt;span class="nv"&gt;dnspython&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;.15.0
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Let's create a context for the above definition file,
execution-environment.yml:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="c1"&gt;# ansible-builder create&lt;/span&gt;
Complete!&lt;span class="w"&gt; &lt;/span&gt;The&lt;span class="w"&gt; &lt;/span&gt;build&lt;span class="w"&gt; &lt;/span&gt;context&lt;span class="w"&gt; &lt;/span&gt;can&lt;span class="w"&gt; &lt;/span&gt;be&lt;span class="w"&gt; &lt;/span&gt;found&lt;span class="w"&gt; &lt;/span&gt;at:&lt;span class="w"&gt; &lt;/span&gt;/root/disconnected_ee/context
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The following issues may arise when building an automation execution
environment in a disconnected environment (this example takes into
account the building of a downstream image):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Cannot reach the external yum repositories.&lt;/li&gt;
&lt;li&gt;Cannot pull Python dependencies from an external PyPI server, so
    using an internal PyPI proxy when building an automation execution
    environment.&lt;/li&gt;
&lt;li&gt;(Optional) SSL certificate issues when pulling from internal PyPI
    mirror.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Firstly, create a pip.conf that points to the local mirror:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="c1"&gt;# cat context/pip.conf&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;global&lt;span class="o"&gt;]&lt;/span&gt;
index-url&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;https://nexus-nexus.apps.celeron.demolab.local/repository/pypi-proxy/simple/
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;You add the above pip.conf file and the certificate to the context
folder for the targeted automation execution environment creation to add
these files inside your custom execution-environment.&lt;/p&gt;
&lt;p&gt;Using the multi-stage build knowledge and context editing, edit the
Containerfile. Note the sections marked in bold text as well as some
comments. These are the changes to build an automation execution
environment in a disconnected fashion.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="c1"&gt;# cat Containerfile&lt;/span&gt;
ARG&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;EE_BASE_IMAGE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;automation-hub.demolab.local/ansible-automation-platform-21/ee-supported-rhel8:latest
ARG&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;EE_BUILDER_IMAGE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;automation-hub.demolab.local/ansible-automation-platform-21/ansible-builder-rhel8:latest

FROM&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$EE_BASE_IMAGE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;as&lt;span class="w"&gt; &lt;/span&gt;galaxy
ARG&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;ANSIBLE_GALAXY_CLI_COLLECTION_OPTS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;
USER&lt;span class="w"&gt; &lt;/span&gt;root

ADD&lt;span class="w"&gt; &lt;/span&gt;_build&lt;span class="w"&gt; &lt;/span&gt;/build
WORKDIR&lt;span class="w"&gt; &lt;/span&gt;/build


FROM&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$EE_BUILDER_IMAGE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;as&lt;span class="w"&gt; &lt;/span&gt;builder
ADD&lt;span class="w"&gt; &lt;/span&gt;_build/requirements.txt&lt;span class="w"&gt; &lt;/span&gt;requirements.txt
RUN&lt;span class="w"&gt; &lt;/span&gt;ansible-builder&lt;span class="w"&gt; &lt;/span&gt;introspect&lt;span class="w"&gt; &lt;/span&gt;--sanitize&lt;span class="w"&gt; &lt;/span&gt;--user-pip&lt;span class="o"&gt;=&lt;/span&gt;requirements.txt&lt;span class="w"&gt; &lt;/span&gt;--write-bindep&lt;span class="o"&gt;=&lt;/span&gt;/tmp/src/bindep.txt&lt;span class="w"&gt; &lt;/span&gt;--write-pip&lt;span class="o"&gt;=&lt;/span&gt;/tmp/src/requirements.txt

&lt;span class="c1"&gt;####### Changes to create EE in a disconnected environment&lt;/span&gt;
&lt;span class="c1"&gt;# Remove ubi repo which tries to reach external links&lt;/span&gt;
RUN&lt;span class="w"&gt; &lt;/span&gt;rm&lt;span class="w"&gt; &lt;/span&gt;-f&lt;span class="w"&gt; &lt;/span&gt;/etc/yum.repos.d/ubi.repo
&lt;span class="c1"&gt;# Add pip.conf for internal pypi proxy&lt;/span&gt;
ADD&lt;span class="w"&gt; &lt;/span&gt;pip.conf&lt;span class="w"&gt; &lt;/span&gt;/etc/pip.conf
&lt;span class="c1"&gt;# Add CA certificate and update trust&lt;/span&gt;
ADD&lt;span class="w"&gt; &lt;/span&gt;demolab-ca.crt&lt;span class="w"&gt; &lt;/span&gt;/etc/pki/ca-trust/source/anchors/demolab-ca.crt
RUN&lt;span class="w"&gt; &lt;/span&gt;update-ca-trust
&lt;span class="c1"&gt;####### This marks the end of edits for the builder stage&lt;/span&gt;

RUN&lt;span class="w"&gt; &lt;/span&gt;assemble

FROM&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$EE_BASE_IMAGE&lt;/span&gt;
USER&lt;span class="w"&gt; &lt;/span&gt;root
COPY&lt;span class="w"&gt; &lt;/span&gt;--from&lt;span class="o"&gt;=&lt;/span&gt;builder&lt;span class="w"&gt; &lt;/span&gt;/output/&lt;span class="w"&gt; &lt;/span&gt;/output/

&lt;span class="c1"&gt;####### Changes to create EE in a disconnected environment&lt;/span&gt;
&lt;span class="c1"&gt;# Remove ubi repo which tries to reach external links&lt;/span&gt;
RUN&lt;span class="w"&gt; &lt;/span&gt;rm&lt;span class="w"&gt; &lt;/span&gt;-f&lt;span class="w"&gt; &lt;/span&gt;/etc/yum.repos.d/ubi.repo
&lt;span class="c1"&gt;# Add pip.conf for internal pypi proxy&lt;/span&gt;
ADD&lt;span class="w"&gt; &lt;/span&gt;pip.conf&lt;span class="w"&gt; &lt;/span&gt;/etc/pip.conf
&lt;span class="c1"&gt;# Add CA certificate and update trust&lt;/span&gt;
ADD&lt;span class="w"&gt; &lt;/span&gt;demolab-ca.crt&lt;span class="w"&gt; &lt;/span&gt;/etc/pki/ca-trust/source/anchors/demolab-ca.crt
RUN&lt;span class="w"&gt; &lt;/span&gt;update-ca-trust
&lt;span class="c1"&gt;####### This marks the end of edits for the main image&lt;/span&gt;

RUN&lt;span class="w"&gt; &lt;/span&gt;/output/install-from-bindep&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;rm&lt;span class="w"&gt; &lt;/span&gt;-rf&lt;span class="w"&gt; &lt;/span&gt;/output/wheels
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;If you look closely in the above Containerfile, you can notice the
additions that fix all the issues previously mentioned in both the
BUILDER and the BASE image stages because both images use this
information to pull and build Python dependencies.&lt;/p&gt;
&lt;p&gt;Understanding what happens in each stage helps you understand where to
edit your Containerfile, and at which stage, allowing you to make
endless customizations to your custom automation execution environments.&lt;/p&gt;
&lt;p&gt;Finally let's build the above execution-environment with the following
command:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;podman&lt;span class="w"&gt; &lt;/span&gt;build&lt;span class="w"&gt; &lt;/span&gt;-f&lt;span class="w"&gt; &lt;/span&gt;context/Containerfile&lt;span class="w"&gt; &lt;/span&gt;-t&lt;span class="w"&gt; &lt;/span&gt;disconnected_ee:1.0
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;When the build succeeds, you should see a message like this:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;--&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;2316db485a1
Successfully&lt;span class="w"&gt; &lt;/span&gt;tagged&lt;span class="w"&gt; &lt;/span&gt;localhost/disconnected_ee:1.0
2316db485a1c4e7be4a687c682d0fc90335372d7e5564774f1ff6451840ac35f
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;Looking forward&lt;/h3&gt;
&lt;p&gt;Our ultimate goal is to make the developer experience as seamless as
possible for customers. Ansible engineering teams are working on
enhancements to the automation execution environment building
experience, with several improvements already in the planning stage.
Until those enhancements are available, this blog should help you tackle
any challenges around the process of building automation execution
environments. Following the upstream first model means you can also
participate in community discussions and provide your thoughts and
feedback through IRC. Please follow the link
&lt;a href="https://docs.ansible.com/ansible/latest/community/communication.html#ansible-community-on-irc"&gt;here&lt;/a&gt;
to join us. One of the main enhancements to the automation execution
environment experience is being discussed in this
&lt;a href="https://github.com/ansible/ansible-builder/pull/411"&gt;GitHub pull request&lt;/a&gt;,
so you can participate in the GitHub discussions as well.&lt;/p&gt;</description><guid>https://ansible.com/blog/the-anatomy-of-automation-execution-environments/</guid><pubDate>Mon, 12 Sep 2022 00:00:00 GMT</pubDate></item><item><title>Migrating from Python virtual environments to automation execution environments in Ansible Automation Platform 2</title><link>https://ansible.com/blog/migrating-from-python-virtual-environments-to-automation-execution-environments-in-ansible-automation-platform-2/</link><dc:creator>Anshul Behl</dc:creator><description>&lt;h2&gt;Migrating from Python virtual environments to automation execution environments in Ansible Automation Platform 2&lt;/h2&gt;
&lt;p&gt;Red Hat Ansible Tower (included in Ansible Automation Platform 1.x)
used Python virtual environments to manage dependencies and implement
consistent automation execution across multiple Red Hat Ansible
Automation Platform instances. This method of managing dependencies came
with its own set of limitations:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Managing Python virtual environments across multiple Ansible Tower instances. &lt;/li&gt;
&lt;li&gt;Confirming custom dependencies across Ansible Tower instances grew in complexity as more end-users interacted with it.&lt;/li&gt;
&lt;li&gt;Python virtual environments were tightly coupled to the control plane, resulting in Operations teams bearing the majority of the burden to maintain them.&lt;/li&gt;
&lt;li&gt;There were no tools supported and maintained by Red Hat to manage custom dependencies across Ansible Automation Platform deployments.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Ansible Automation Platform 2 introduced automation execution environments.
These are container images in which all automation is packaged and run,
which includes components such as Ansible Core, Ansible Content
Collections, a version of Python, Red Hat Enterprise Linux UBI 8, and any additional
package dependencies.&lt;/p&gt;
&lt;h2&gt;Why should you upgrade?&lt;/h2&gt;
&lt;p&gt;Ansible Automation Platform 2, &lt;a href="https://www.redhat.com/en/about/press-releases/red-hat-ansible-automation-platform-2-drives-cloud-native-automation-and-helps-developers-become-automators"&gt;announced at AnsibleFest 2021&lt;/a&gt;,
comes with a re-imagined architecture that fully decouples the
automation control plane and execution plane. The new capabilities
enable easier to scale automation across the globe and allow you to run
your automation as close to the source as possible without being bound
to running automation in a single data center. It's more dynamic,
scalable, resilient and secure compared to Ansible Automation Platform 1.2.&lt;/p&gt;
&lt;p&gt;If you are an existing Red Hat customer using Ansible Automation
Platform 1.2 (Ansible Tower 3.8), an important migration recommendation
is to convert any custom Python virtual environments in your cluster to
automation execution environments. This one-time effort opens the door
to take advantage of the latest Ansible Automation Platform 2
capabilities and the ability to execute consistent automation across
multiple platforms with lower long-term maintenance.&lt;/p&gt;
&lt;p&gt;We will now explain this specific migration consideration and provide
you with some best practices on how to migrate to automation execution
environments.&lt;/p&gt;
&lt;h2&gt;The manual process of upgrading&lt;/h2&gt;
&lt;p&gt;As outlined in this
&lt;a href="https://docs.ansible.com/automation-controller/4.1.0/html/upgrade-migration-guide/upgrade_to_ees.html"&gt;document&lt;/a&gt;,
the manual process of upgrading to automation execution environments
would go something like this:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Prerequisite is a running Ansible Automation Platform 1.2 cluster
    where customers have configured one or more custom Python virtual
    environments in addition to the default one.&lt;/li&gt;
&lt;li&gt;Use the
    &lt;code&gt;awx-manage&lt;/code&gt;
    command line utility present on the Ansible Tower node to get the
    list of custom Python virtual environments using the
    &lt;code&gt;list_custom_venvs&lt;/code&gt; subcommand.&lt;/li&gt;
&lt;li&gt;Run the &lt;code&gt;awx-manage export_custom_venv&lt;/code&gt;
    command on each virtual environment to get the list of Python
    packages installed in that virtual environment.&lt;/li&gt;
&lt;li&gt;Check the association of a virtual environment using the
    &lt;code&gt;awx-manage custom_venv_associations&lt;/code&gt;
    command. This list of associations/information will help customers
    make associations of new execution environments in the Ansible
    Automation Platform 2.x cluster.&lt;/li&gt;
&lt;li&gt;Filtering the above information manually and feeding the list of
    requirements from step 3 above to the execution environment builder
    (ansible-builder) to create necessary custom execution
    environment(s).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Looking at the above process there can be two enhancements to this flow,
which would help customers adopt automation execution environments
faster:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Exported requirements from step 3 above can be compared with the
    list of Python packages already present in the automation execution
    environment that will serve as the base layer for the newly created
    ones. This will be helpful, because there are dependencies that will
    already be resolved by the base automation execution environment and
    it will help customers if they can focus on &lt;strong&gt;what's needed&lt;/strong&gt; when
    they start creating automation execution environments for their
    clusters.&lt;/li&gt;
&lt;li&gt;Since we love Ansible, why not just automate the above process,
    right? :)&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;The automated process of upgrading&lt;/h2&gt;
&lt;p&gt;The intent of this section is to explain how you can automate this
process using Ansible. We have a few example Ansible Content Collections
and roles that can be used to achieve this automation. The playbook
would look something like this at a high level:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Pull the list of packages from all the custom Python virtual
    environments present on the Ansible Tower node in Ansible Automation
    Platform 1.2.&lt;/li&gt;
&lt;li&gt;Compare the package lists from step 1 with the package list in the
    automation execution environment you decide to use as basis
    (ansible-2.9 in our example), to find the packages that are not
    present in the base.&lt;/li&gt;
&lt;li&gt;List from step 2 can be fed to an Ansible Role that can automate the
    execution environment creation, keeping the base  as the one we did
    the comparison with in step 2.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Let's take an existing Ansible Automation Platform 1.2 setup that has
two custom virtual environments, called custom-venv1 and custom-venv2,
which both have their own list of Python packages:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="c1"&gt;# awx-manage export_custom_venv /opt/my-envs/custom-venv1/ -q&lt;/span&gt;
&lt;span class="l l-Scalar l-Scalar-Plain"&gt;certifi==2021.10.8&lt;/span&gt;
&lt;span class="l l-Scalar l-Scalar-Plain"&gt;charset-normalizer==2.0.10&lt;/span&gt;
&lt;span class="l l-Scalar l-Scalar-Plain"&gt;enum34==1.1.10&lt;/span&gt;
&lt;span class="l l-Scalar l-Scalar-Plain"&gt;future==0.18.2&lt;/span&gt;
&lt;span class="l l-Scalar l-Scalar-Plain"&gt;idna==3.3&lt;/span&gt;
&lt;span class="l l-Scalar l-Scalar-Plain"&gt;requests==2.27.1&lt;/span&gt;
&lt;span class="l l-Scalar l-Scalar-Plain"&gt;solidfire-sdk-python==12.3.0.203&lt;/span&gt;
&lt;span class="l l-Scalar l-Scalar-Plain"&gt;urllib3==1.26.8&lt;/span&gt;

&lt;span class="l l-Scalar l-Scalar-Plain"&gt;# awx-manage export_custom_venv /opt/my-envs/custom-venv2/ -q&lt;/span&gt;
&lt;span class="l l-Scalar l-Scalar-Plain"&gt;zabbix-api==0.5.4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;We will use a role packaged in the &lt;a href="https://galaxy.ansible.com/redhat_cop/ee_utilities"&gt;redhat_cop.ee_utilities Collection&lt;/a&gt;
called &lt;code&gt;virtualenv_migrate&lt;/code&gt;, that is designed for this specific purpose
and run that against the Ansible Tower node. Below is a sample playbook
and inventory file respectively:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="nn"&gt;---&lt;/span&gt;
&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;Review custom virtualenvs and diff packages from base EE&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;hosts&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;tower&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;become&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;true&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;vars&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;venv_migrate_ee_python_list&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p p-Indicator"&gt;[]&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;tasks&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;Include venv_migrate role&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="nt"&gt;include_role&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;redhat_cop.ee_utilities.virtualenv_migrate&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;[tower]&lt;/span&gt;
&lt;span class="na"&gt;ansibletower.demoredhat.com&lt;/span&gt;

&lt;span class="k"&gt;[local]&lt;/span&gt;
&lt;span class="na"&gt;localhost&lt;/span&gt;

&lt;span class="k"&gt;[all:vars]&lt;/span&gt;
&lt;span class="na"&gt;venv_migrate_default_ee_url&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"registry.redhat.io/ansible-automation-platform-21/ee-29-rhel8:latest"&lt;/span&gt;
&lt;span class="na"&gt;registry_username&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;myRedHatID&lt;/span&gt;
&lt;span class="na"&gt;registry_password&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;mypassword&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The output of the playbook is shown below. It did the comparison as
expected and gave us the list of packages from custom Python virtual
environments that were not present in the base automation execution
environment.&lt;/p&gt;
&lt;p&gt;NOTE: The version based comparison for PIP packages is not included at this moment.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;TASK&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;redhat_cop.tower_utilities.virtualenv_migrate&lt;span class="w"&gt; &lt;/span&gt;:&lt;span class="w"&gt; &lt;/span&gt;diff&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;Show&lt;span class="w"&gt; &lt;/span&gt;the&lt;span class="w"&gt; &lt;/span&gt;packages&lt;span class="w"&gt; &lt;/span&gt;that&lt;span class="w"&gt; &lt;/span&gt;are&lt;span class="w"&gt; &lt;/span&gt;extra&lt;span class="w"&gt; &lt;/span&gt;from&lt;span class="w"&gt; &lt;/span&gt;default&lt;span class="w"&gt; &lt;/span&gt;EEs&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;custom&lt;span class="w"&gt; &lt;/span&gt;venvs.&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;******************************************************************************
ok:&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt;.228.23.40&lt;span class="w"&gt; &lt;/span&gt;-&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;localhost&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="s2"&gt;"msg"&lt;/span&gt;:&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="s2"&gt;"/opt/my-envs/custom-venv1/"&lt;/span&gt;:&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="s2"&gt;"certifi"&lt;/span&gt;,
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="s2"&gt;"charset-normalizer"&lt;/span&gt;,
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="s2"&gt;"enum34"&lt;/span&gt;,
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="s2"&gt;"future"&lt;/span&gt;,
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="s2"&gt;"solidfire-sdk-python"&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="o"&gt;}&lt;/span&gt;,
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="s2"&gt;"/opt/my-envs/custom-venv2/"&lt;/span&gt;:&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="s2"&gt;"zabbix-api"&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The above output can be directly passed to another Ansible Role in the
same &lt;a href="https://galaxy.ansible.com/redhat_cop/ee_utilities"&gt;redhat_cop.ee_utilities Collection&lt;/a&gt;
called
&lt;a href="https://github.com/redhat-cop/ee_utilities/tree/main/roles/ee_builder"&gt;ee_builder&lt;/a&gt;;
its use case is to automate the execution environment creation process.&lt;/p&gt;
&lt;p&gt;Briefly summing things up:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We ran a playbook against the Ansible Tower node to gather Python
    packages (from custom Python virtual environments) that are not in
    the base automation execution environment.&lt;/li&gt;
&lt;li&gt;Output from above can help the creation of custom automation
    execution environments using the ee_builder role that automates
    execution environment creation.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Key takeaways&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Using this new Ansible Role in combination with the ee_builder role
    can be used to automate the migration from custom virtual
    environments to automation execution environments.&lt;/li&gt;
&lt;li&gt;These roles are currently part of a community project and not
    officially supported by Red Hat. However, they can provide details
    in the understanding of the migration process.&lt;/li&gt;
&lt;/ul&gt;</description><guid>https://ansible.com/blog/migrating-from-python-virtual-environments-to-automation-execution-environments-in-ansible-automation-platform-2/</guid><pubDate>Wed, 16 Feb 2022 00:00:00 GMT</pubDate></item><item><title>Introduction to ansible-test</title><link>https://ansible.com/blog/introduction-to-ansible-test/</link><dc:creator>Anshul Behl</dc:creator><description>&lt;h2&gt;Introduction to ansible-test&lt;/h2&gt;
&lt;p&gt;As automation becomes crucial for more and more business cases, there is
an increased need to test the automation code itself. This is where
ansible-test comes in: developers who want to test their Ansible Content
Collections for sanity, unit and integration tests can use 
ansible-test  to achieve testing workflows that integrate with source
code repositories.&lt;/p&gt;
&lt;p&gt;Both ansible-core and ansible-base come
&lt;a href="https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html"&gt;packaged&lt;/a&gt;
with a cli tool called ansible-test, which can be used by collection
developers to test their Collection and its content. The ansible-test
knows how to perform a wide variety of testing-related tasks, from
linting module documentation and code to running unit and integration
tests.&lt;/p&gt;
&lt;p&gt;We will cover different features of ansible-test in brief below.&lt;/p&gt;
&lt;h2&gt;How to run ansible-test?&lt;/h2&gt;
&lt;p&gt;With the general availability of Ansible Content Collections with Ansible-2.9,
a user can run ansible-test inside a collection to test the collection
itself. ansible-test needs to be run from the collection root or below
in order for ansible-test to run tests on the Collection.&lt;/p&gt;
&lt;p&gt;If you try to run ansible-test from outside the above directory norms,
it will throw an error like below:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;root@root&lt;span class="w"&gt; &lt;/span&gt;~/.ansible/collections&lt;span class="w"&gt; &lt;/span&gt;ansible-test&lt;span class="w"&gt; &lt;/span&gt;sanity
ERROR:&lt;span class="w"&gt; &lt;/span&gt;The&lt;span class="w"&gt; &lt;/span&gt;current&lt;span class="w"&gt; &lt;/span&gt;working&lt;span class="w"&gt; &lt;/span&gt;directory&lt;span class="w"&gt; &lt;/span&gt;must&lt;span class="w"&gt; &lt;/span&gt;be&lt;span class="w"&gt; &lt;/span&gt;at&lt;span class="w"&gt; &lt;/span&gt;or&lt;span class="w"&gt; &lt;/span&gt;below:

-&lt;span class="w"&gt; &lt;/span&gt;an&lt;span class="w"&gt; &lt;/span&gt;Ansible&lt;span class="w"&gt; &lt;/span&gt;collection:&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;...&lt;span class="o"&gt;}&lt;/span&gt;/ansible_collections/&lt;span class="o"&gt;{&lt;/span&gt;namespace&lt;span class="o"&gt;}&lt;/span&gt;/&lt;span class="o"&gt;{&lt;/span&gt;collection&lt;span class="o"&gt;}&lt;/span&gt;/

Current&lt;span class="w"&gt; &lt;/span&gt;working&lt;span class="w"&gt; &lt;/span&gt;directory:&lt;span class="w"&gt; &lt;/span&gt;/root/.ansible/collections
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;from the above output you can see how a collection root appears to
ansible-test, it has to be in the form of:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="o"&gt;{&lt;/span&gt;...&lt;span class="o"&gt;}&lt;/span&gt;/ansible_collections/&lt;span class="o"&gt;{&lt;/span&gt;namespace&lt;span class="o"&gt;}&lt;/span&gt;/&lt;span class="o"&gt;{&lt;/span&gt;collection&lt;span class="o"&gt;}&lt;/span&gt;/
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;When you install a collection from Ansible Galaxy or Automation Hub, the default installation location is:
&lt;code&gt;{...}/ansible_collections/{namespace}/{collection}/&lt;/code&gt;, which already satisfies the above directory convention.&lt;/p&gt;
&lt;p&gt;Even if you specify the installation path to the ansible-galaxy cli
(using the -p option), it will also install a collection inside the
ansible_collections directory by creating one in the given path, like
below:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;root@root&lt;span class="w"&gt; &lt;/span&gt;~/temp&lt;span class="w"&gt; &lt;/span&gt;ll
total&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;

root@root&lt;span class="w"&gt; &lt;/span&gt;~/temp&lt;span class="w"&gt; &lt;/span&gt;ansible-galaxy&lt;span class="w"&gt; &lt;/span&gt;collection&lt;span class="w"&gt; &lt;/span&gt;install&lt;span class="w"&gt; &lt;/span&gt;arista.eos&lt;span class="w"&gt; &lt;/span&gt;-p&lt;span class="w"&gt; &lt;/span&gt;.
Process&lt;span class="w"&gt; &lt;/span&gt;install&lt;span class="w"&gt; &lt;/span&gt;dependency&lt;span class="w"&gt; &lt;/span&gt;map
Starting&lt;span class="w"&gt; &lt;/span&gt;collection&lt;span class="w"&gt; &lt;/span&gt;install&lt;span class="w"&gt; &lt;/span&gt;process
Installing&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;'arista.eos:1.2.0'&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;to&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;'/root/temp/ansible_collections/arista/eos'&lt;/span&gt;
Installing&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;'ansible.netcommon:1.4.1'&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;to&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;'/root/temp/ansible_collections/ansible/netcommon'&lt;/span&gt;

root@root&lt;span class="w"&gt; &lt;/span&gt;~/temp&lt;span class="w"&gt; &lt;/span&gt;ll
total&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;4&lt;/span&gt;.0K
drwxrwxr-x.&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;4&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;root&lt;span class="w"&gt; &lt;/span&gt;root&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;4&lt;/span&gt;.0K&lt;span class="w"&gt; &lt;/span&gt;Jan&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;18&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;19&lt;/span&gt;:21&lt;span class="w"&gt; &lt;/span&gt;ansible_collections
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Make sure you keep the above directory norm when you develop your
collections and test them with ansible-test too, in your local
development environment.&lt;/p&gt;
&lt;h3&gt;How to test your collection using ansible-test?&lt;/h3&gt;
&lt;p&gt;ansible-test provides ways to run different types of tests on your
Collections, broadly these tests are of types listed below:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sanity Tests&lt;/li&gt;
&lt;li&gt;Unit Tests&lt;/li&gt;
&lt;li&gt;Integration Tests&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We will go through each of these tests in detail.&lt;/p&gt;
&lt;h3&gt;Sanity Tests&lt;/h3&gt;
&lt;p&gt;Sanity tests are made up of scripts and tools used to perform static
code analysis. The primary purpose of these tests is to enforce Ansible
coding standards and requirements. ansible-test includes a variety of
sanity tests to perform the code analysis, which can be found
&lt;a href="https://docs.ansible.com/ansible/latest/dev_guide/testing/sanity/index.html#all-sanity-tests"&gt;in the documentation&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;How to run?&lt;/h3&gt;
&lt;p&gt;You can run the sanity test suite from the root directory of your
collection; below are different scenarios on how you can run the sanity
tests.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="c1"&gt;# Run all sanity tests&lt;/span&gt;
ansible-test&lt;span class="w"&gt; &lt;/span&gt;sanity

&lt;span class="c1"&gt;# Run all sanity tests against against certain files&lt;/span&gt;
ansible-test&lt;span class="w"&gt; &lt;/span&gt;sanity&lt;span class="w"&gt; &lt;/span&gt;plugins/modules/files/eos_acls.py

&lt;span class="c1"&gt;# Run all tests with a specific version of python (3.7 in this case)&lt;/span&gt;
ansible-test&lt;span class="w"&gt; &lt;/span&gt;sanity&lt;span class="w"&gt; &lt;/span&gt;--python&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt;.7

&lt;span class="c1"&gt;# Run all tests inside docker (good if you don't have dependencies installed)&lt;/span&gt;
ansible-test&lt;span class="w"&gt; &lt;/span&gt;sanity&lt;span class="w"&gt; &lt;/span&gt;--docker&lt;span class="w"&gt; &lt;/span&gt;default

&lt;span class="c1"&gt;# Run validate-modules against a specific file&lt;/span&gt;
ansible-test&lt;span class="w"&gt; &lt;/span&gt;sanity&lt;span class="w"&gt; &lt;/span&gt;--test&lt;span class="w"&gt; &lt;/span&gt;validate-modules&lt;span class="w"&gt; &lt;/span&gt;lib/ansible/modules/files/template.py
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;To list all the sanity tests available:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;ansible-test&lt;span class="w"&gt; &lt;/span&gt;sanity&lt;span class="w"&gt; &lt;/span&gt;--list-tests
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;How to ignore sanity tests?&lt;/h4&gt;
&lt;p&gt;Since sanity tests change between Ansible releases, a separate ignore
file is needed for each Ansible major release.&lt;/p&gt;
&lt;p&gt;The filename is &lt;code&gt;tests/sanity/ignore-X.Y.txt&lt;/code&gt;
where &lt;code&gt;X.Y&lt;/code&gt; is the &lt;code&gt;ansible-core/ansible-base&lt;/code&gt; release being used to test the collection.&lt;/p&gt;
&lt;p&gt;Maintaining a separate file for each Ansible release allows a collection to pass tests for multiple versions of Ansible.&lt;/p&gt;
&lt;p&gt;For information on the format of the ignore files, please refer to the
&lt;a href="https://docs.ansible.com/ansible/latest/dev_guide/testing/sanity/ignores.html#ignore-file-format"&gt;dev guide&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;There are only a limited number of cases where ignores would be needed, so please refer to the
&lt;a href="https://github.com/ansible-collections/overview/blob/main/collection_requirements.rst#ci-testing"&gt;collections documentation&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Unit Tests&lt;/h3&gt;
&lt;p&gt;Unit tests are small isolated tests that target a specific library or
module. As a collection developer/maintainer, you want to make sure that
your code is unit tested, and ansible-test provides a way to run and do
reporting of unit tests inside your collection.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The tests/units is where all things related to unit testing live&lt;/li&gt;
&lt;li&gt;ansible-test uses PyTest underneath the surface to do unit testing, hence it expects the tests to be located in files starting with &lt;code&gt;test_&lt;/code&gt; or ending with &lt;code&gt;_test.py&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;For more information on how to write unit tests, please refer to the
&lt;a href="https://docs.ansible.com/ansible/latest/dev_guide/testing_units_modules.html"&gt;guide&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To run all the unit tests inside a collection, run the below command
from collection root:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="c1"&gt;# Run all tests inside docker (good if you don't have dependencies installed)&lt;/span&gt;
ansible-test&lt;span class="w"&gt; &lt;/span&gt;units&lt;span class="w"&gt; &lt;/span&gt;--docker&lt;span class="w"&gt; &lt;/span&gt;-v
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Against a single module file by doing:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="c1"&gt;# Only runs if the module directory path and unit test file path are similar&lt;/span&gt;
ansible-test&lt;span class="w"&gt; &lt;/span&gt;units&lt;span class="w"&gt; &lt;/span&gt;--docker&lt;span class="w"&gt; &lt;/span&gt;-v&lt;span class="w"&gt; &lt;/span&gt;apt
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Or against a specific python version by doing:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;ansible-test&lt;span class="w"&gt; &lt;/span&gt;units&lt;span class="w"&gt; &lt;/span&gt;--docker&lt;span class="w"&gt; &lt;/span&gt;-v&lt;span class="w"&gt; &lt;/span&gt;--python&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;.7&lt;span class="w"&gt; &lt;/span&gt;apt
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;If you are running unit tests against things other than modules, such as
module utilities, specify the whole file path:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;ansible-test&lt;span class="w"&gt; &lt;/span&gt;units&lt;span class="w"&gt; &lt;/span&gt;--docker&lt;span class="w"&gt; &lt;/span&gt;-v&lt;span class="w"&gt; &lt;/span&gt;test/units/module_utils/basic/test_imports.py
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;For advanced usage, see the help:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;ansible-test&lt;span class="w"&gt; &lt;/span&gt;units&lt;span class="w"&gt; &lt;/span&gt;--help
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;Code Coverage&lt;/h3&gt;
&lt;p&gt;Code coverage reports make it easy to identify untested code for which
more tests should be written.&lt;/p&gt;
&lt;p&gt;Add the &lt;code&gt;--coverage&lt;/code&gt;= option to any test
command to collect code coverage data. If you aren't using the
&lt;code&gt;--venv&lt;/code&gt; or &lt;code&gt;--docker&lt;/code&gt; options that create an isolated
python environment, then you may have to use the &lt;code&gt;--requirements&lt;/code&gt;
option to ensure that the correct version of
the coverage module is installed:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;ansible-test&lt;span class="w"&gt; &lt;/span&gt;coverage&lt;span class="w"&gt; &lt;/span&gt;erase
ansible-test&lt;span class="w"&gt; &lt;/span&gt;units&lt;span class="w"&gt; &lt;/span&gt;--coverage&lt;span class="w"&gt; &lt;/span&gt;apt
ansible-test&lt;span class="w"&gt; &lt;/span&gt;coverage&lt;span class="w"&gt; &lt;/span&gt;html
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Reports can be generated in several different formats:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ansible-test coverage report&lt;/code&gt; - Console report.&lt;/li&gt;
&lt;li&gt;[&lt;code&gt;ansible-test coverage html&lt;/code&gt; - HTML report.&lt;/li&gt;
&lt;li&gt;[&lt;code&gt;ansible-test coverage xml&lt;/code&gt; - XML report.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To clear data between test runs, use the ansible-test coverage erase
command. For a full list of features, see the online help:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;ansible-test&lt;span class="w"&gt; &lt;/span&gt;coverage&lt;span class="w"&gt; &lt;/span&gt;--help
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;Integration Tests&lt;/h3&gt;
&lt;p&gt;These are end to end tests to check code path functions as expected and
to catch breaking changes in the product that you are trying to
automate. In the context of ansible-test essentially:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The &lt;code&gt;tests/integration&lt;/code&gt; is where all things related to integration tests live.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;tests/integration/targets&lt;/code&gt; directory contains all our test cases.
    Each test case is a barebones Ansible Role.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Conclusion &amp;amp; Next Steps&lt;/h2&gt;
&lt;p&gt;As shown above, ansible-test can provide a lot of value testing Ansible
Content Collections thoroughly.&lt;/p&gt;
&lt;p&gt;For further reading and information, visit the
&lt;a href="https://docs.ansible.com/ansible/latest/dev_guide/testing.html"&gt;Ansible Testing Strategies documentation&lt;/a&gt;.
If you are unfamiliar with Ansible Collections, check out our
&lt;a href="https://youtube.com/playlist?list=PLdu06OJoEf2Z85Lrc7_Sdw6mTt4aSKfwt"&gt;YouTube playlist for everything about Ansible Collections&lt;/a&gt;.
The videos will get you up to speed quickly.&lt;/p&gt;
&lt;p&gt;Also, don't forget to check out our &lt;a href="https://www.redhat.com/en/engage/infra-automation-ebook-s-202009020400"&gt;Automate infrastructure workflows e-book&lt;/a&gt;
if you want to learn more about building a unified, automated pipeline for infrastructure operations.&lt;/p&gt;</description><guid>https://ansible.com/blog/introduction-to-ansible-test/</guid><pubDate>Mon, 22 Feb 2021 00:00:00 GMT</pubDate></item></channel></rss>