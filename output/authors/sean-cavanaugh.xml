<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Ansible Collaborative (Posts by Sean Cavanaugh)</title><link>https://ansible.com/</link><description></description><atom:link href="https://ansible.com/authors/sean-cavanaugh.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2024 &lt;a href="mailto:website@ansible.community"&gt;Ansible Collaborative, et al&lt;/a&gt; </copyright><lastBuildDate>Mon, 18 Mar 2024 19:47:35 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Using Ansible and Packer, From Provisioning to Orchestration</title><link>https://ansible.com/blog/ansible-and-packer-why-they-are-better-together/</link><dc:creator>Sean Cavanaugh</dc:creator><description>&lt;h2&gt;Using Ansible and Packer, From Provisioning to Orchestration&lt;/h2&gt;
&lt;p&gt;Red Hat Ansible Automation Platform can help you orchestrate,
operationalize and govern your hybrid cloud deployments.  In my last
public cloud blog, I talked about "Two Simple Ways Automation Can Save
You Money on Your AWS Bill"
and similarly to Ashton's blog "Bringing Order to the Cloud: Day 2
Operations in AWS with Ansible",
we both wanted to look outside the common public cloud use-case of
provisioning and deprovisioning resources and instead look at automating
common operational tasks.  For this blog post I want to cover how the
Technical Marketing team for Ansible orchestrates a pipeline for demos
and workshops with Ansible and how we integrate that with custom AMIs
(Amazon Machine Images) created with &lt;a href="https://www.packer.io/"&gt;Packer&lt;/a&gt;. 
Packer is an open source tool that allows IT operators to standardize
and automate the process of building system images.&lt;/p&gt;
&lt;p&gt;For some of our &lt;a href="https://red.ht/ansible_labs"&gt;self-paced interactive hands-on labs on Ansible.com&lt;/a&gt;, we can quickly spin up images
in seconds.  In an example automation pipeline we will:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Provision a virtual instance.&lt;/li&gt;
&lt;li&gt;Use Ansible Automation Platform to install an application; in my
    case, I am literally installing our product Ansible Automation
    Platform (is that too meta?).&lt;/li&gt;
&lt;li&gt;After the application install, set up the lab guides, pre-load
    automation controller with some job templates, create inventory and
    credentials and even set up SSL certificates.  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;While this is fast, it might take a few minutes to load, and web users
are unlikely to be patient.  The Netflix era means that people want
instant gratification!  Installing automation controller might take five
to 10 minutes, so I need a faster method to deploy.&lt;/p&gt;
&lt;p&gt;&lt;img alt="cloud automation pipeline diagram" src="https://ansible.com/images/posts/archive/ansible-packer-blog-one.png"&gt;&lt;/p&gt;
&lt;p&gt;What I can do is combine our normal Ansible automation pipeline with
Packer and pre-build the cloud instances so they already have the
application installed, and are configured and ready to go as soon as it
boots.  Packer will provision a specific machine image on my public
cloud (Azure, AWS, GCP), run the commands and changes I need, and then
publish a new image with all the changes I made to the base image.  In
my case I use Ansible the same way.  In my packer
&lt;a href="https://www.packer.io/docs/templates/hcl_templates"&gt;HCL&lt;/a&gt; (HashiCorp
Configuration Language ) file I have an Ansible provisioner:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;provisio&lt;/span&gt;&lt;span class="kc"&gt;ner&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;"ansible"&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="err"&gt;comma&lt;/span&gt;&lt;span class="kc"&gt;n&lt;/span&gt;&lt;span class="err"&gt;d&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;"ansible-playbook"&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="err"&gt;playbook_&lt;/span&gt;&lt;span class="kc"&gt;f&lt;/span&gt;&lt;span class="err"&gt;ile&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;"pre_build_controller.yml"&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="err"&gt;user&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;"ec2-user"&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="err"&gt;i&lt;/span&gt;&lt;span class="kc"&gt;n&lt;/span&gt;&lt;span class="err"&gt;ve&lt;/span&gt;&lt;span class="kc"&gt;nt&lt;/span&gt;&lt;span class="err"&gt;ory_&lt;/span&gt;&lt;span class="kc"&gt;f&lt;/span&gt;&lt;span class="err"&gt;ile_&lt;/span&gt;&lt;span class="kc"&gt;te&lt;/span&gt;&lt;span class="err"&gt;mpla&lt;/span&gt;&lt;span class="kc"&gt;te&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;"controller ansible_host={{ .Host }} ansible_user={{ .User }} ansible_port={{ .Port }}"&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="err"&gt;ex&lt;/span&gt;&lt;span class="kc"&gt;tra&lt;/span&gt;&lt;span class="err"&gt;_argume&lt;/span&gt;&lt;span class="kc"&gt;nts&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;local.ex&lt;/span&gt;&lt;span class="kc"&gt;tra&lt;/span&gt;&lt;span class="err"&gt;_args&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Red Hat Ansible Tech Marketing Example can be found on
&lt;a href="https://github.com/ansible/workshops/blob/devel/provisioner/packer/automation-controller.pkr.hcl"&gt;Github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This simple provisioner plugin is executing the Ansible Playbook
pre_build_controller.yml.  I can also use Ansible Automation Platform to
orchestrate the whole process by kicking off Packer and then continuing
on.  Anything that I can do ahead of time, I can pre-build into the
image.  This means there is less automation I need to do at boot time
(or what is sometimes referred to as "automation just in time").  The
new process looks like this diagram:&lt;/p&gt;
&lt;p&gt;&lt;img alt="create pre-built image diagram" src="https://ansible.com/images/posts/archive/ansible-packer-blog-two.png"&gt;&lt;/p&gt;
&lt;p&gt;These two processes, building images and serving a demo environment, are
actually independent of each other.  Depending on how often a pre-built
image needs to be executed, we can schedule that in automation
controller, or even generate them on-demand via
&lt;a href="https://docs.ansible.com/automation-controller/latest/html/userguide/webhooks.html"&gt;webhooks&lt;/a&gt;.
On-demand generation means as soon as someone changes an Ansible
Playbook relevant to anything pre_build, we can have Ansible Automation
Platform create the new image immediately, and even test it!&lt;/p&gt;
&lt;h2&gt;Sharing and copying cloud instances&lt;/h2&gt;
&lt;p&gt;Once we create a pre_built AMI, we need to make sure we can use it in
multiple regions, and on other accounts. With public marketplace
instances you can use cool automation tricks like using the
&lt;a href="https://docs.ansible.com/ansible/latest/collections/amazon/aws/ec2_ami_info_module.html"&gt;ec2_ami_info module&lt;/a&gt; for dynamic lookups,
but we have now essentially created private AMIs we can copy to other
regions, or share to other AWS accounts so they have access to these
pre_built images.  To solve this problem we can use automation, and I
have created an Ansible Content Collection for
&lt;a href="https://galaxy.ansible.com/ansible_cloud/share_ami"&gt;ansible_cloud.share_ami&lt;/a&gt;.  &lt;/p&gt;
&lt;p&gt;This Collection currently has two roles available that will assist cloud
administrators, copy and share.&lt;/p&gt;
&lt;h3&gt;Copy&lt;/h3&gt;
&lt;p&gt;This role will copy an AMI from one region, to any other specified
regions.  This means you can use Packer to create it just once, and have
Ansible take care of copying it to any other regions and return you with
a list of new AMIs per region.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;copy&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ami&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;include_role&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ansible_cloud&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;share_ami&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;copy&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;vars&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;ami_list&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;"{{ my_ami_list }}"&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;copy_to_regions&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;"{{ my_copy_to_regions }}"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Where your variable file looks like this:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;my_ami_list&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;ap&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;northeast&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ami&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;01334&lt;/span&gt;&lt;span class="n"&gt;example&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;ap&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;southeast&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ami&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="n"&gt;b3f3example&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;eu&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;central&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ami&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;03&lt;/span&gt;&lt;span class="n"&gt;a5732example&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;us&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;east&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ami&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;01&lt;/span&gt;&lt;span class="n"&gt;da94de9cexample&lt;/span&gt;
&lt;span class="n"&gt;my_copy_to_regions&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;us&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;west&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;us&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;east&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In this case, there will be four AMIs copied to us-west-1 and us-east-2
with a new AMI identifier returned to your terminal window or the
automation controller console.&lt;/p&gt;
&lt;h3&gt;Share&lt;/h3&gt;
&lt;p&gt;This role will share an AMI
from one account and region to another account (in the same region). 
This allows you to share your pre_built AMIs to as many accounts as you
want really quickly.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;share&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ami&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;include_role&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ansible_cloud&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;share_ami&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;share&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;vars&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;user_id_list&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;"{{ account_list }}"&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;ami_list&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;"{{ my_ami_list }}"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Where your variable file looks like this:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;my_ami_list&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;ap&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;northeast&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ami&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;01334&lt;/span&gt;&lt;span class="n"&gt;example&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;ap&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;southeast&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ami&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="n"&gt;b3f3example&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;eu&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;central&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ami&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;03&lt;/span&gt;&lt;span class="n"&gt;a5732example&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;us&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;east&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ami&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;01&lt;/span&gt;&lt;span class="n"&gt;da94de9cexample&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;us&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;east&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ami&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;009&lt;/span&gt;&lt;span class="n"&gt;f8b2c6dexample&lt;/span&gt;
&lt;span class="n"&gt;account_list&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;"11463example"&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;"90073example"&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;"71963example"&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;"07923example"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This would share these five AMIs to the four accounts listed.  There are
also two optional variables for share AMI, new_ami_name and new_tag
which will name (e.g. add the tag name: "whatever you put") and add a
hard coded ansiblecloud tag (e.g. add the tag ansiblecloud: "whatever
you put").  This could be further customized to add as many tags as you
want to your AMIs to help keep track of them.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;new_ami_name: "RHEL 8.6 with automation controller"
new_tag: "my test"
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now you can see one of the many ways that Ansible Automation Platform
and Packer can easily and seamlessly work together to accomplish cloud
automation tasks.  If you want more blogs on Ansible and Packer or
Ansible and Terraform, please let us know!&lt;/p&gt;</description><guid>https://ansible.com/blog/ansible-and-packer-why-they-are-better-together/</guid><pubDate>Mon, 03 Oct 2022 00:00:00 GMT</pubDate></item><item><title>Ansible versus Terraform Demystified</title><link>https://ansible.com/blog/ansible-vs.-terraform-demystified/</link><dc:creator>Sean Cavanaugh</dc:creator><description>&lt;h2&gt;Ansible versus Terraform Demystified&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Consider also checking out the article &lt;a href="https://www.redhat.com/en/topics/automation/ansible-vs-terraform"&gt;Ansible vs. Terraform&lt;/a&gt;, clarified on RedHat.com&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Ansible and Terraform are two very powerful but unique open source IT
tools that are often compared in competitive discussions.  We often see
comparisons of the two tools - but many times, these comparisons are
done purely from a "spec sheet" comparison. This type of comparison,
while an interesting read, doesn't take into account using the products
at scale or if the comparison is realistic as a binary all-or-nothing
approach. We at Red Hat have been helping enterprises for over 20 years
and have a good idea how most IT administrators are using these two
tools in production. Although both tools &lt;em&gt;can&lt;/em&gt; generally do most things,
we typically see that they are each leveraged by means of their biggest
strengths as opposed to having to choose one or the other.&lt;/p&gt;
&lt;p&gt;Spoiler:  The two tools are better together and can work in harmony to
create a better experience for developers and operations teams.&lt;/p&gt;
&lt;p&gt;Both Ansible and Terraform are open source tools with huge user bases,
which often leads to cult followings because of the classical "hammer"
approach.  That is, if my only tool is a hammer, every problem will
start resembling a nail. This ends up trying to solve new problems the
only way I know how, rather than trying another tool that might be more
effective.  It is never a great idea to only understand one tool and its
approach and philosophy. Instead, you should open your mind to
understanding why different tools and platforms exist, and why
successful organizations may be using both.  In this blog we will go
over the differences and similarities between Ansible and Terraform, the
open source projects and their downstream enterprise products.  Keep in
mind that this is a blog and to check the date for relevancy as products
and projects are constantly changing and evolving.&lt;/p&gt;
&lt;h3&gt;Terraform&lt;/h3&gt;
&lt;p&gt;Terraform is an open source project that is sponsored by the company
HashiCorp. Terraform is one of several open source projects that have
been productized by HashiCorp; other projects include Vagrant, Packer,
Consul and Vault.  HashiCorp specifically has a design philosophy called
the &lt;a href="https://www.hashicorp.com/tao-of-hashicorp"&gt;Tao of HashiCorp&lt;/a&gt; where
they want their projects and products to be simple, modular, and
composable. In this case, each project and product pairing has well
defined scopes and for larger workflows you would combine multiple
projects and products.  They define Terraform with the following
purpose:&lt;/p&gt;
&lt;p&gt;Terraform is the infrastructure as code offering from HashiCorp. It is
a tool for building, changing, and managing infrastructure in a safe,
repeatable way. Operators and Infrastructure teams can use Terraform to
manage environments with a configuration language called the HashiCorp
Configuration Language (HCL) for human-readable, automated
deployments. &lt;a href="https://learn.hashicorp.com/tutorials/terraform/infrastructure-as-code"&gt;source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Terraform is mainly command-line only, but is well integrated with a set
of popular public clouds. Terraform is great at provisioning fixed sets
of cloud infrastructure and tearing them down afterwards.  HashiCorp
provides two productization methods of Terraform for customers, they can
either self-manage their custom deployment with Terraform Enterprise or
they can use their managed service &lt;a href="https://www.hashicorp.com/products/terraform/pricing"&gt;Terraform Cloud&lt;/a&gt;.
Their
business tier provides drift detection, SSO Audit logs, self-hosted
agents and customized concurrency.&lt;/p&gt;
&lt;h3&gt;Ansible&lt;/h3&gt;
&lt;p&gt;Ansible is an IT automation tool. It can configure systems, deploy
software, and orchestrate more advanced IT tasks such as continuous
deployments or zero downtime rolling updates.  Most people are familiar
with community Ansible, which is the command-line tool for running
Ansible Playbooks.  Like Terraform, Ansible focuses on simplicity and
ease-of-use.  Ansible uses &lt;a href="https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html"&gt;YAML syntax&lt;/a&gt; for
Ansible playbooks.  We use YAML because it is easier for humans to read
and write than other common data formats like XML or JSON.&lt;/p&gt;
&lt;p&gt;Red Hat Ansible Automation Platform is the product that is offered to
customers.  It is built on the foundations of Ansible with numerous
enterprise features, combining more than a dozen upstream projects into
an integrated, streamlined product. Each product component also has a
specific purpose with a well defined scope similar to HashiCorp's design
philosophy.  For example, the automation controller is the Web UI and
API for Ansible automation, which is based on the upstream project AWX.
 This component is bundled into the platform to manage automation.
Ansible Automation Platform is available to be &lt;a href="https://www.redhat.com/en/technologies/management/ansible/trial?extIdCarryOver=true&amp;amp;sc_cid=701f2000000txokAAA"&gt;run on-premises&lt;/a&gt; and
charged by node (rather than by user) or you can use the
&lt;a href="https://www.redhat.com/en/technologies/management/ansible/azure"&gt;managed service offering on Microsoft Azure&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To summarize, both Ansible and Terraform have open source command-line
only versions.  They both have products available with enterprise
features such as a Web UI or SSO.  The primary difference for their
community versions is that Ansible is an multi-purpose automation tool,
whereas Terraform is an infrastructure as code tool.  The confusion
starts occurring because there are numerous use cases that could
potentially be solved by either tool, and both Ansible and Terraform
have plugins to call each other.  For example, many Ansible experts
simply provision AWS resources with an Ansible Playbook and might not
understand why others use an entirely different tool. Similarly,
Terraform experts might create and destroy entire instances for even the
smallest configuration change (see next section about immutability).&lt;/p&gt;
&lt;h3&gt;Immutable Infrastructure: The Killer App?&lt;/h3&gt;
&lt;p&gt;Terraform takes an immutable approach to infrastructure.  If you are
unfamiliar with immutable infrastructure, it is defined as instances
that do not change over time or are unable to be changed. To greatly
simplify, an IT operator can create a declarative file (a Terraform HCL
file) that represents in structured data what they want their end-state
cloud footprint to look like and deploy this with Terraform.  One of the
advantages of this approach is that it creates a single source of truth
(that HCL file) that can be deployed over and over again without having
to understand how it gets to the end-state.  This approach can be simple
and elegant for individuals getting started quickly but depending on the
size of infrastructure can become &lt;a href="https://www.youtube.com/watch?v=wRgQxfrFJYU"&gt;complex and hard to manage&lt;/a&gt;.
Another advantage
of an immutable approach is that it is just as easy to tear down
(de-provision) your cloud resources. This allows developers to quickly
spin up resources, test something, then tear them down.&lt;/p&gt;
&lt;p&gt;Ansible, by design, takes an imperative approach to automation.  You
simply have a task list that iterates through each resource.  You would
tell it to provision this VPC, this subnet, then this VM.  The advantage
of this approach is it is very simple to understand, there is no hidden
magic, which helps it become easy to troubleshoot.  The disadvantage is
usually it is more cumbersome to do teardowns and de-provision without
knowing the correct order.  I have to delete the instance, then the
security group, and so on and so forth. However, Ansible has support for
calling both AWS CloudFormation (another immutable and declarative
approach for AWS), and Terraform.  In fact, Ansible Automation Platform
does this for all major public clouds, and encourages people to use
their preference for provisioning and de-provisioning.  This is a great
example of how Terraform and Ansible are better together.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Important:&lt;/strong&gt; Although Ansible is not universally immutable, depending
on how you implement your individual tasks, some Ansible tasks can be
immutable.&lt;/p&gt;
&lt;p&gt;Here's an example: You can have an Ansible Playbook that provisions a
Linux virtual machine into a public cloud using a CloudFormation
Template, and then subsequently installs an application via the
&lt;a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/dnf_module.html"&gt;dnf Ansible module&lt;/a&gt;.
This activity would be entirely immutable by Ansible.  Most Ansible
modules are designed to be
&lt;a href="https://docs.ansible.com/ansible/latest/reference_appendices/glossary.html#term-Idempotency"&gt;idempotent&lt;/a&gt; so
that they only make changes when they need to.  Ansible is extremely
flexible, and it's easy to just automate shell commands which are not
idempotent and change every time the playbook is run.  This showcases
how Ansible shines as a multi-purpose automation tool versus a discrete
infrastructure as code tool.  &lt;/p&gt;
&lt;h3&gt;Use Cases Compared&lt;/h3&gt;
&lt;p&gt;If you read all the articles about Terraform, you will find they are
public-cloud focused. This is where immutable infrastructure works well
and Terraform is great at provisioning cloud resources and applications
for AWS, Azure, Docker, GCP, and OCI.  However, there is more to IT
operations than automated infrastructure provisioning and this is why
Ansible is extremely popular as well.  This is not a knock on Terraform,
it is a specific tool with a specific purpose and ethos designed
purposely to do infrastructure as code.  However, this infrastructure as
code wholly depends on how you define your infrastructure.  Is my
critical Cisco IOS network switch not infrastructure?  IT Infrastructure
can mean a lot of different things to different IT administrators
depending on if they are a network engineer, cloud operations engineer,
system administrator or have another title or role.&lt;/p&gt;
&lt;p&gt;Ansible focuses on automation with a variety of use cases that are
typically divided up into domains, due to their legacy silos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Infrastructure automation - includes automation of Linux and
    Microsoft Windows, as well as storage vendors like NetApp,
    PureStorage, and HPE.&lt;/li&gt;
&lt;li&gt;Network automation - includes physical switches, routers, load
    balancers, and SDN controllers from popular vendors such as Arista,
    Cisco, F5 and Juniper.&lt;/li&gt;
&lt;li&gt;Security automation - integrates SIEM, IDPS, and firewalls from
    vendors like IBM, Checkpoint, and ITSM tools like ServiceNow.  &lt;/li&gt;
&lt;li&gt;Edge and hybrid cloud footprints.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Moving to an Event-Driven IT Strategy&lt;/h3&gt;
&lt;p&gt;As opposed to Terraform, Ansible is more focused on the entire IT
workflow. For example, consider the following workflow:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Deploy a Web Application to AWS.&lt;/li&gt;
&lt;li&gt;Update your ServiceNow ITSM with Web Application Information.&lt;/li&gt;
&lt;li&gt;Run a schedule to check every hour that the Web Application is
    responding on the correct ports &lt;em&gt;or&lt;/em&gt; use event streams to monitor
    ports and the application for further automation.&lt;/li&gt;
&lt;li&gt;Update/Create a ServiceNow ticket if the Web Application stops
    responding and attempts automation for remediation.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In the above example, it is not enough to simply provision a web
application into a public cloud.  There are other steps that need to
take place in this automation workflow.  We need the automation to sync
with the customer\'s ITSM tool, and include event-driven checks for the
web application to ensure it is operating correctly (we call this
continuous IT compliance).  Stateful automation can even guarantee this
service is kept running while human operators make changes out of band
from your automation.&lt;/p&gt;
&lt;h3&gt;Better: Ansible Orchestrating Terraform&lt;/h3&gt;
&lt;p&gt;Terraform is an excellent cloud provisioning and de-provisioning tool
for infrastructure as code.  Ansible is a great all-purpose,
cross-domain automation solution.  Both have an amazing open source
communities and well supported downstream paid products.  What we see
with the community, customers and even our own IT workflows is that you
can combine these tools and solutions to create even more amazing IT
workflows.  If you are already invested with Terraform, Ansible simply
allows you to wrap those HCL templates into more holistic automation
workflows. Ansible further extends your automation allowing you to add
tasks like configuration management and application deployment to the
Terraform IaC deployment.&lt;/p&gt;
&lt;h3&gt;How are people using Ansible?&lt;/h3&gt;
&lt;p&gt;We've noticed that many IT administrators refer to the specific "cloud
deployment and retirement" use case rather than looking at other cloud
operations use cases, such as Day 2 operations.  To help spark some
ideas, let's highlight some Ansible cloud automation use cases today
outside of just provisioning and de-provisioning cloud resources.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Infrastructure visibility -&lt;/strong&gt; This is simply using Ansible to
    retrieve information from your public clouds to understand your
    cloud footprint.  This is very helpful for brownfield environments
    where there are numerous IT administrators configuring resources
    out-of-band from each other.  When there isn't a forced IT process,
    it is a great starter use case because it is read-only and requires
    no production changes.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Compliance -&lt;/strong&gt; We need to not only treat cloud infrastructure as
    code, but also the cloud as code.  For example, we can enforce IAM
    policies and make sure there is a common experience across public
    clouds.  Another example would be to force a tag policy across your
    instances for billing and auditing and shutting down instances out
    of compliance.  What's great about Ansible is that it can operate
    and enforce these policies on mutable and immutable infrastructure.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Business continuity -&lt;/strong&gt; Ansible can help keep the lights on.  Move
    and copy resources off cloud, create and manage policies for backups
    and build automation to manage disruptions and failures.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cloud operations -&lt;/strong&gt; Ansible can automate Day 2 activities.  This
    includes application deployments and CI/CD pipelines, lifecycle
    management and enforcement as well as OS patching and maintenance.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cloud migration -&lt;/strong&gt; Ansible can help move workloads to where you
    need them.  For example, adopting automation for your on-premises
    infrastructure can help operators adopt public cloud.  Making sure
    your source of truth is automation versus the on-box configurations
    is the first step for cloud migration.  Ansible automation can also
    reduce friction for migration to cloud native, allowing developers
    to migrate off legacy infrastructure.  By using Ansible automation,
    an IT group can help unify automation architecture across legacy and
    cloud-native.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Infrastructure optimization -&lt;/strong&gt; Adopting clouds can help IT
    operators save time and money, but initially it\'s hard to predict
    costs and understand how your billing requirements change.  Having
    an automation strategy can help you keep costs under control by
    turning off unused resources, rightsizing cloud resources and
    combining with use cases like infrastructure visibility, you can
    easily recover orphaned resources and make sure there are no
    surprise costs.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Infrastructure orchestration -&lt;/strong&gt; We talked about this previously,
    but how are you integrating everything that's not in your public
    cloud? Orchestration is simply how we break down silos and integrate
    with infrastructure outside the cloud.  This allows IT operators to
    orchestrate business outcomes versus tech silos and apply consistent
    compliance across all infrastructure.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Automated troubleshooting -&lt;/strong&gt; As your IT team gains confidence
    with automation, we can move towards an event-driven architecture.
     This allows IT teams to respond faster to incidents, speed up
    meantime to resolution and integrate with an organization's ITSM
    solution.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Are people succeeding?&lt;/h3&gt;
&lt;p&gt;The quick answer? Yes! Even automating Terraform with Ansible! But
holistic automation goes beyond doing one thing well in the cloud.
Ansible can automate and orchestrate physical, virtual and cloud
resources. It can automate the provisioning, configuration management,
and manage Day 2 operations of network devices, Windows servers, storage
and of course Linux. But regardless of what people decide to use to
solve a problem, we've found that the real issues aren't with "what" or
"how" a problem is solved from a technology perspective, but more about
standardizing across technology domains while growing up and out to
scale across the entire IT organization.&lt;/p&gt;
&lt;p&gt;One of the most impressive and recent success stories using Ansible
Automation Platform in the cloud was by Asian Development Bank. The
published &lt;a href="https://www.redhat.com/en/resources/asian-development-bank-case-study"&gt;case study&lt;/a&gt;
details how they modernized their infrastructure while at the same time
modernizing their workforce, allowing them more time to focus on more
important things, like innovative projects and new service offerings.
They standardized on Terraform for Day 0 while standardizing on Ansible
Automation Platform for Day 1 and Day 2 operations. Check out their
story in the embedded
&lt;a href="https://www.redhat.com/en/resources/asian-development-bank-case-study"&gt;video&lt;/a&gt;!&lt;/p&gt;
&lt;h3&gt;Final Thoughts&lt;/h3&gt;
&lt;p&gt;The confusion between Ansible and Terraform has existed for some time,
either through inaccurate (or outdated) source material or through
inexperience in using either/both technologies. This blog post (while
somewhat biased) should help to at least start the conversation around
the deeper connections between Ansible and Terraform. Every situation,
use case, and person implementing the solution can be different, but
because of these factors we believe Ansible is the best solution for
automation.&lt;/p&gt;</description><guid>https://ansible.com/blog/ansible-vs.-terraform-demystified/</guid><pubDate>Tue, 13 Sep 2022 00:00:00 GMT</pubDate></item><item><title>Two Simple Ways Automation Can Save You Money on Your AWS Bill</title><link>https://ansible.com/blog/two-simple-ways-automation-can-save-money-on-aws/</link><dc:creator>Sean Cavanaugh</dc:creator><description>&lt;h2&gt;Two Simple Ways Automation Can Save You Money on Your AWS Bill&lt;/h2&gt;
&lt;p&gt;Red Hat Ansible Automation Platform is an excellent automation and
orchestration tool for public clouds. For this post, I am going to walk
through two common scenarios where Ansible Automation Platform can help
out. I want to look outside the common public cloud use-case of
provisioning and deprovisioning resources and instead look at automating
common operational tasks.&lt;/p&gt;
&lt;p&gt;&lt;img alt="cloud engineer diagram" src="https://ansible.com/images/posts/archive/cloud-engineer-diagram.png"&gt;&lt;/p&gt;
&lt;p&gt;What is an operational task? It is simply anything that an administrator
has to do outside of creating and deleting cloud resources (e.g.
instances, networks, keys, etc.) to help maintain their company's
public cloud account. One of the problems I've encountered is instances
being left on, running up our public cloud bill in the background while
we were focusing our attention elsewhere. The more users you have, the
more likely problems are to occur; automation can help address these
issues and maintain control of your account. There are two common
scenarios I want to address here:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Bespoke AWS instances were manually created for a one-off
    initiative, usually to test something, then instances were forgotten
    about and left running.&lt;/li&gt;
&lt;li&gt;Continuous Integration (CI) instances were spun up to test changes
    programmatically every time a Pull Request (PR) went into our
    project, and would sometimes hit a corner case where not everything
    was deprovisioned correctly (turned off).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In both cases, orphaned instances can be left on for a long time.
Imagine you spun up a couple dozen instances to test something on a
public cloud, then you got busy, lost track of time and forgot to
terminate the instances before stopping work for the day. That might be
16 hours (at minimum) of time when you were charged and received no
value out of the public cloud that your company was financing. Now
multiply this by dozens of users and that bill can end up in tens of
thousands of dollars really quickly.&lt;/p&gt;
&lt;h3&gt;Use-case one: dealing with bespoke orphaned instances&lt;/h3&gt;
&lt;p&gt;So let's tackle each of these issues and use Ansible Automation
Platform to automate a solution for the first scenario above where
instances are being spun up outside any automation guard rails (i.e.
they are not using any automation tools, including Ansible, to spin up
cloud resources). We require everyone on my team who has access to the
public cloud account to tag their instances. They must create a key,
pair tag that says: &lt;code&gt;owner: person&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="inventory tags screenshot" src="https://ansible.com/images/posts/archive/inventory-tags.png"&gt;&lt;/p&gt;
&lt;p&gt;This creates a really easy way to audit and see who (which person,
organization, or team) is accountable for billing, which is half the
battle. I am going to write a very simple Ansible Playbook that will
enforce this. I will use the fully supported amazon.aws collection to
demonstrate this.  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;amazon.aws&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;downstream content fully supported on &lt;a href="https://cloud.redhat.com/ansible/automation-hub/repo/published/amazon/aws"&gt;Ansible automation hub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;upstream code found on &lt;a href="https://galaxy.ansible.com/amazon/aws"&gt;Ansible Galaxy&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The primary difference between the community and supported Collections
here is support with your Red Hat subscription. There is also
significant integration testing, code auditing and Python 3 / boto3
support with the fully supported amazon.aws collection that is included
as part of your Red Hat subscription.&lt;/p&gt;
&lt;h3&gt;Dealing with untagged instances&lt;/h3&gt;
&lt;p&gt;In my first Ansible Playbook, I want to get a list of all instances that
have no tags. First, let's retrieve all instances in a particular
region that are running:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;grab info for un-tagged instances&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;amazon.aws.ec2_instance_info&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;region&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;ec2_region&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}"&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;filters&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="nt"&gt;instance-state-name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;running&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;register&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;ec2_node_info&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;I am using the ec2_instance_info module found in the AWS Collection,
part of the Amazon namespace. This task retrieves all instances
(regardless of tags). I found the easiest way was to grab everything
then filter out for empty tags:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;set the untagged to a var&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;set_fact&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;untagged_instances&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;ec2_node_info.instances&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;|&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;selectattr('tags',&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;'equalto',&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;{})&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;|&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;map(attribute='instance_id')&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;|&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;list&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This
&lt;a href="https://docs.ansible.com/ansible/latest/user_guide/complex_data_manipulation.html#data-manipulation"&gt;selectattr&lt;/a&gt;
filter is simply matching any instance that has no tags with the
&lt;code&gt;['tags', 'equalto', {} ]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;I can then simply terminate these since my colleague didn't follow my
well establish guidelines:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;Terminate every un-tagged running instance in a region.&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;amazon.aws.ec2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;region&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;ec2_region&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}"&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;state&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;absent&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;instance_ids&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;untagged_instances&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}"&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;when&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;untagged_instances | length  &amp;gt; 0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;However, since you might be more forgiving than me, you could use
&lt;code&gt;state: stopped&lt;/code&gt; versus
absent which will turn them off versus terminate them.&lt;/p&gt;
&lt;h3&gt;Retrieving any instances with missing tags&lt;/h3&gt;
&lt;p&gt;To expand on the above, we don't just care about instances that are
untagged entirely (meaning there are no tags at all), but we are
specifically looking for the owner tag. I now want to retrieve any
instance that is missing the owner tag. I can use the exact same logic
as above but instead use the selectattr filter to look for undefined. &lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;set the missing tag to a var&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;set_fact&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;missing_tag&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;ec2_node_info.instances&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;|&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;selectattr('tags.owner',&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;'undefined')&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;|&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;map(attribute='instance_id')&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;|&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;list&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;I wanted to show both examples above to give a path to
operationalization. Implementing the above using Ansible Automation
Platform, your organization can now understand that they need to use
tags, or their instances will be turned off (or worse!). Going further,
the organization could use automation to enforce a particular tag to
assign ownership, or action on the instance will be taken. You could use
one or both of these previous examples.&lt;/p&gt;
&lt;h3&gt;Use-case two: Dealing with automated instances&lt;/h3&gt;
&lt;p&gt;For my particular use-case I have a code repository that is
automatically tested. Our code is tested nightly, and everytime there is
a Pull Request (PR) into the code repository. The CI testing will
provision instances on AWS, configure the instances, run through
automated tests, then deprovision them. Sometimes the deprovisioning
step will not complete successfully, leaving orphaned hosts. One of the
common things I have noticed is that the instances are often found
partially turned off, where their tags are completely missing (removed)
but the instances are not actually off, so we are still getting billed.
The above Ansible Playbook in the previous example can catch that.&lt;/p&gt;
&lt;p&gt;However another great test is to use a new uptime parameter.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;grab info&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;amazon.aws.ec2_instance_info&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;region&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;ec2_region&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}"&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;uptime&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;121&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;filters&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="nt"&gt;instance-state-name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p p-Indicator"&gt;[&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"running"&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p p-Indicator"&gt;]&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="s"&gt;"tag:ansible-workshops"&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;true&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;register&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;ec2_node_info&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In this task there are two parameters I want to call out. First is the
uptime parameter (added in the 1.4.0 of amazon.aws), which will only
return instances that have run for more than that integer in minutes.
For this example it has to run for more than 121 minutes, or more than
two hours. I know that my CI testing should never take more than two
hours. Either the instance is stuck, my automated testing broke, or
deprovisioning didn't happen successfully.&lt;/p&gt;
&lt;p&gt;The other tag here is simply a filter so that I only return instances
that are part of my automated testing (versus other initiatives). In
this example, it has to be a
&lt;a href="https://github.com/ansible/workshops"&gt;workshop&lt;/a&gt;. Now it should click
why I need the "no tagged" example at the beginning! This entire
operational task will fail if there is no tag at all. So the no tags
use-case overlaps with every other use case because of how important
tags can be in public cloud infrastructure. &lt;/p&gt;
&lt;h3&gt;Automating the automation&lt;/h3&gt;
&lt;p&gt;So this automation is great and all, but manually running playbooks only
saves you so much time. I went ahead and used the &lt;a href="https://docs.ansible.com/ansible-tower/latest/html/userguide/workflows.html"&gt;Ansible workflows&lt;/a&gt;
feature to hit multiple regions at once, and then schedule it so that my
automation jobs run every hour.&lt;/p&gt;
&lt;p&gt;&lt;img alt="ansible workflow diagrams" src="https://ansible.com/images/posts/archive/automating-automation.png"&gt;&lt;/p&gt;
&lt;p&gt;Each rectangle on the right represents an automation
&lt;a href="https://docs.ansible.com/ansible-tower/latest/html/userguide/job_templates.html"&gt;job&lt;/a&gt;.
Each job in the same column is run in parallel on my Ansible Automation
Platform cluster. Each job template is set to a different region. I also
used the &lt;a href="https://docs.ansible.com/ansible-tower/latest/html/userguide/job_templates.html#surveys"&gt;survey feature&lt;/a&gt;
to make this easy to configure from the Web UI.&lt;/p&gt;
&lt;p&gt;&lt;img alt="screenshot" src="https://ansible.com/images/posts/archive/aws-untagged-instances.png"&gt;&lt;/p&gt;
&lt;p&gt;In my particular scenario I was running automated testing in four AWS
regions (us-east-1, ap-northeast-1, ap-southeast-1 and eu-central-1).
Now that my workflow is complete, it is trivial to schedule my workflow
to run every hour.&lt;/p&gt;
&lt;p&gt;&lt;img alt="screenshot" src="https://ansible.com/images/posts/archive/schedule-details-ui.png"&gt;&lt;/p&gt;
&lt;p&gt;Voila! Now I have automated testing behind the scenes to make sure that
no orphaned instances are running. For my particular use case this will
save a lot of money, and force a culture of accountability around public
cloud use so that costs are clear and transparent between team
members.  &lt;/p&gt;</description><guid>https://ansible.com/blog/two-simple-ways-automation-can-save-money-on-aws/</guid><pubDate>Mon, 14 Mar 2022 00:00:00 GMT</pubDate></item><item><title>How to Migrate your Ansible Playbooks to Support AWS boto3</title><link>https://ansible.com/blog/how-to-migrate-your-ansible-playbooks-to-support-aws-boto3/</link><dc:creator>Sean Cavanaugh</dc:creator><description>&lt;h2&gt;How to Migrate your Ansible Playbooks to Support AWS boto3&lt;/h2&gt;
&lt;p&gt;Red Hat Ansible Automation Platform is known for automating Linux,
Windows and networking infrastructure. While both the community version
of Ansible and our enterprise offering, Red Hat Ansible Automation
Platform, are prominently known for configuration management, this is
just a small piece of what you can really achieve with Ansible's
automation. There are many other use-cases that Ansible Automation
Platform is great at automating, such as your AWS, Azure or Google
public cloud &lt;/p&gt;
&lt;p&gt;&lt;img alt="diagram of Ansible on public clouds" src="https://ansible.com/images/posts/archive/ansible-public-clouds.png"&gt;&lt;/p&gt;
&lt;p&gt;Ansible Automation Platform can automate deployments, migrations and
operational tasks for your public cloud. This is extremely powerful
because you can orchestrate your entire infrastructure
&lt;a href="https://docs.ansible.com/automation-controller/latest/html/userguide/workflows.html"&gt;workflow&lt;/a&gt;,
from cloud deployment, to instance configuration, to retirement, rather
than requiring a point tool for each separate use-case. This also allows
IT administrators to concentrate on automating business outcomes rather
than individual technology silos.&lt;/p&gt;
&lt;p&gt;Specifically for this blog, I wanted to cover converting your Ansible
Playbooks for provisioning an instance on AWS from the unsupported ec2
module to the fully supported ec2_instance module. Amazon has deprecated
their Software Development Kit (SDK) Boto in favor of the newer fully
supported SDK Boto3. Alina Buzachis announced "What's New: The Ansible
AWS Collection 2.0 Release" back in October 2021, which includes full
support in our Red Hat Ansible Certified Content Collection for the
amazon.aws.ec2_instance module, which uses Python 3 and Boto3.&lt;/p&gt;
&lt;p&gt;The supported ec2_instance module has existed for some time, but I had
not adopted it for my use-case yet because we needed one last feature
for parity with the older ec2 module.  Specifically, for demos and
workshops, I required the exact_count parameter. This allows me to boot
as many identical instances as I specify. For example, if I specify
exact_count: 50, it will spin up 50 identical Red Hat Enterprise Linux 8
instances.  &lt;/p&gt;
&lt;p&gt;Using exact_count can save hours of time versus using a loop, and I
don't need a massive declarative file to represent my 50 servers; it's
just a tweak of a single parameter to make identical copies. &lt;a href="https://github.com/ansible-collections/amazon.aws/pull/539"&gt;Luckily we
know that we have
parameter&lt;/a&gt;,
so I started converting all workshops and demos that the technical
marketing team uses to Boto3.&lt;/p&gt;
&lt;p&gt;Let's look at an older version of a task file from our technical
workshops so I can show you how to convert from ec2 to
&lt;a href="https://docs.ansible.com/ansible/latest/collections/amazon/aws/ec2_instance_module.html#ansible-collections-amazon-aws-ec2-instance-module"&gt;ec2_instance&lt;/a&gt;:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="nn"&gt;---&lt;/span&gt;
&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;Create EC2 instances for RHEL8&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;ec2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;assign_public_ip&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;true&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;key_name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;ec2_name_prefix&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}-key"&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;group&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;ec2_security_group&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}"&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;instance_type&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;ec2_info[rhel8].size&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}"&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;image&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;node_ami_rhel.image_id&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}"&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;region&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;ec2_region&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}"&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;exact_count&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;student_total&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}"&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;count_tag&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;Workshop_node1"&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;ec2_name_prefix&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}-node1"&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;instance_tags&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;Workshop_node1"&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;ec2_name_prefix&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}-node1"&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="nt"&gt;Workshop&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;ec2_name_prefix&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}"&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="nt"&gt;Workshop_type&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;workshop_type&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}"&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;ec2_wait&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}"&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;vpc_subnet_id&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;ec2_vpc_subnet_id&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}"&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;volumes&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;device_name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;/dev/sda1&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nt"&gt;volume_type&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;gp2&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nt"&gt;volume_size&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;ec2_info[control_type].disk_space&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}"&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nt"&gt;delete_on_termination&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;true&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;register&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;control_output&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;For booting an instance into AWS, there are only six required
parameters. You need to specify a key (i.e. the SSH key to access the
image), security group (virtual firewall for your ec2 instances),
instance_type (e.g. t2.medium), a region (i.e. us-east-1), image (e.g.
an AMI for RHEL8) and a network interface or VPC subnet id
(vpc_subnet_id). &lt;/p&gt;
&lt;p&gt;The rest of the parameters in my task above are for:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tweaking the instance&lt;/li&gt;
&lt;li&gt;adding a public IP address, increasing storage&lt;/li&gt;
&lt;li&gt;changing the module behavior&lt;ul&gt;
&lt;li&gt;wait refers to waiting for the instance to reach running state,&lt;/li&gt;
&lt;li&gt;exact_count refers to provisioning multiple instances in
    parallel&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;tagging, which is just adding key value tags to the instance so we
    can filter on them in subsequent automation, or just sort easily in
    the AWS web console.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To convert this to ec2_instance, there are only a few small tweaks you
need to make!&lt;/p&gt;
&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;ec2:&lt;/th&gt;
    &lt;th&gt;ec2_instance:&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;&lt;code&gt;assign_public_ip: true&lt;/code&gt;&lt;/pre&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;pre&gt;&lt;code&gt;network:
          assign_public_ip: true&lt;/code&gt;&lt;/pre&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;&lt;code&gt;group: "{{ ec2_security_group }}"&lt;/code&gt;&lt;/pre&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;pre&gt;&lt;code&gt;security_group: "{{ ec2_security_group }}"&lt;/code&gt;&lt;/pre&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;&lt;code&gt;image: "{{ node_ami_rhel.image_id }}"&lt;/code&gt;&lt;/pre&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;pre&gt;&lt;code&gt;image_id: "{{ node_ami_rhel.image_id }}"&lt;/code&gt;&lt;/pre&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;&lt;code&gt;count_tag:
  Workshop_node1": "{{ ec2_name_prefix }}-node1"&lt;/code&gt;&lt;/pre&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;pre&gt;&lt;code&gt;filters:
  "tag:Workshop_node1": "{{ ec2_name_prefix }}-node1"
&lt;/code&gt;&lt;/pre&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;&lt;code&gt;instance_tags:&lt;/code&gt;&lt;/pre&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;pre&gt;&lt;code&gt;tags:&lt;/code&gt;&lt;/pre&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;&lt;code&gt;volumes:
  - device_name: /dev/sda1
  volume_type: gp2
  volume_size: "{{ ec2_info[control_type].disk_space }}"
  delete_on_termination: true&lt;/code&gt;&lt;/pre&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;pre&gt;&lt;code&gt;volumes:
- device_name: /dev/sda1
  ebs:
  volume_type: gp2
  volume_size: "{{ ec2_info[rhel].disk_space }}"
  delete_on_termination: true&lt;/code&gt;&lt;/pre&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;The entire modified task looks like the following:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;Create EC2 instances for node1&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;ec2_instance&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;key_name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;ec2_name_prefix&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}-key"&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;security_group&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;ec2_security_group&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}"&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;instance_type&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;ec2_info[rhel].size&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}"&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;image_id&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;node_ami_rhel.image_id&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}"&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;region&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;ec2_region&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}"&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;exact_count&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;student_total&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}"&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;network&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="nt"&gt;assign_public_ip&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;true&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;filters&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="s"&gt;"tag:Workshop_node1"&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;ec2_name_prefix&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}-node1"&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;tags&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="nt"&gt;Workshop_node1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;ec2_name_prefix&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}-node1"&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="nt"&gt;Workshop&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;ec2_name_prefix&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}"&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="nt"&gt;uuid&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;ec2_name_prefix&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}"&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="nt"&gt;guid&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;ec2_name_prefix&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}"&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="nt"&gt;Workshop_type&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;workshop_type&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}"&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;ec2_wait&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}"&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;vpc_subnet_id&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;ec2_vpc_subnet_id&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}"&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;volumes&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;device_name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;/dev/sda1&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nt"&gt;ebs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="nt"&gt;volume_type&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;gp2&lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="nt"&gt;volume_size&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;ec2_info[rhel].disk_space&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}"&lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="nt"&gt;delete_on_termination&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;While the task may look long, realize that optional tags are taking up
seven lines... which is OK, and I am displaying many default values.
Remember that there is no additional cost to add tags to cloud
resources, and they help with subsequent automation and filtering. I
once heard a colleague exclaim that you can never have too many tags!&lt;/p&gt;
&lt;p&gt;Looking at the task above, you will see that anything with the tag
Workshop_node1: "-node1" will be used to verify whether existing
instances match. It will make sure that exact_count of instances exist
with the tag Workshop_node1. This can also be used in subsequent
automation to filter and retrieve just the instances you want.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;grab instance ids to tag rtr1&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;ec2_instance_info&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;region&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;ec2_region&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}"&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;filters&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="s"&gt;"tag:Workshop_node1"&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;ec2_name_prefix&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}-node1"&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;register&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;node1_output&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This will retrieve all instances with their common tag. You will also
probably require unique tags for each instance. In that case, I
recommend the ec2_tag module, where
&lt;a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html"&gt;looping&lt;/a&gt;
is less time intensive (versus looping with the ec2_instance module):&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;Ensure tags are present for node1&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;ec2_tag&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;region&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;ec2_region&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}"&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;resource&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;item.1.instance_id&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}"&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;state&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;present&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;tags&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="nt"&gt;Name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;ec2_name_prefix&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}-student{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;item.0&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;+&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;1&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}-node1"&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="nt"&gt;Index&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;item[0]&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}"&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="nt"&gt;Student&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"student{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;item.0&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;+&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;1&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}"&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="nt"&gt;launch_time&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;item.1.launch_time&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}"&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;with_indexed_items&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;node1_output.instances&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}"&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;when&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;node1_output.instances|length &amp;gt; 0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The ec2_tag module is great for when you need unique tags for a
particular cloud resource. In the example above, the name, index,
student identifier and launch time are unique for that resource. Again
there is no time punishment or cost to additional tags, so tag as much
as you want. So the workflow for provisioning a bunch of instances on
AWS would look like the following:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;provisioning in bulk &lt;code&gt;exact_count&lt;/code&gt; amount of instances&lt;/li&gt;
&lt;li&gt;register the output to a variable with either &lt;code&gt;ec2_instance&lt;/code&gt; or &lt;code&gt;ec2_instance_info&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;for unique tags, loop over the instances with the &lt;code&gt;ec2_tag&lt;/code&gt; module&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Thank you for reading through my blog and I hope this helped you on your Ansible cloud automation journey.&lt;/p&gt;</description><guid>https://ansible.com/blog/how-to-migrate-your-ansible-playbooks-to-support-aws-boto3/</guid><pubDate>Mon, 07 Mar 2022 00:00:00 GMT</pubDate></item><item><title>Five ways to get started with network automation</title><link>https://ansible.com/blog/five-ways-to-get-started-with-network-automation/</link><dc:creator>Sean Cavanaugh</dc:creator><description>&lt;h2&gt;Five ways to get started with network automation&lt;/h2&gt;
&lt;p&gt;As many of you know, Red Hat Ansible Automation Platform is a highly
flexible IT automation platform that can automate your Linux and Windows
instances, your VMware private cloud, your AWS, Azure or Google public
cloud, and even your security infrastructure.  Today I want to write
about one of my favorite use-cases; using Ansible Automation Platform
for network automation. It provides easy, highly customizable automation
for your routers and switches so you can automate them just like any
other IT infrastructure.&lt;/p&gt;
&lt;p&gt;However, even though network automation has become increasingly popular,
most organizations are still managing their network infrastructure
manually by a CLI or GUI. Why is this? This manual CLI work often means
that network engineers are reactive and constantly drowning with
break-fix network issues because of manual mis-configurations, or the
inability to implement change quickly and efficiently.&lt;/p&gt;
&lt;p&gt;Because network engineers are so busy firefighting in their day job,
they don't have time to look at a new activity like automating, even
though automation will save them time and money in the long run. I
fundamentally believe that network automation is not an all or nothing
situation.  You need to adopt network automation in small increments so
you can earn yourself, and your team more time.  In other words, start
small and think big. I put together this
&lt;a href="https://youtu.be/wXUgYfZKMHU"&gt;video to help network engineers brainstorm five great use cases for network automation&lt;/a&gt;.
This list is not exhaustive; there are many more use-cases that you can do with network automation,
but this is meant to give network administrators an idea of what is possible.&lt;/p&gt;
&lt;p&gt;If you're looking to learn more about a specific use-case, you can jump
right to it:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=wXUgYfZKMHU&amp;amp;t=176s"&gt;configuration backup and restore&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=wXUgYfZKMHU&amp;amp;t=534s"&gt;infrastructure awareness&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=wXUgYfZKMHU&amp;amp;t=1015s"&gt;scoped configuration management&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=wXUgYfZKMHU&amp;amp;t=1259s"&gt;operational state validation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=wXUgYfZKMHU&amp;amp;t=1606s"&gt;automated netops&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=wXUgYfZKMHU&amp;amp;t=1870s"&gt;wrap up and next steps&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description><guid>https://ansible.com/blog/five-ways-to-get-started-with-network-automation/</guid><pubDate>Mon, 21 Feb 2022 00:00:00 GMT</pubDate></item><item><title>Ansible Network Resource Purge parameter</title><link>https://ansible.com/blog/ansible-network-resource-purge-parameter/</link><dc:creator>Sean Cavanaugh</dc:creator><description>&lt;h2&gt;Ansible Network Resource Purge parameter&lt;/h2&gt;
&lt;p&gt;Red Hat Ansible Network Automation continues to be a popular domain for
Red Hat Ansible Automation Platform. We have continually developed
additional &lt;a href="https://docs.ansible.com/ansible/latest/network/user_guide/network_resource_modules.html"&gt;resource modules&lt;/a&gt;
to make automating network appliances easier, and more approachable, for
novices and experts alike. These resource modules provide a consistent
experience across multiple network vendors. There are seven
main state parameters for resource modules: merged, replaced,
overridden, deleted, gathered, rendered and parsed. The Ansible network
team is adding one more parameter, purged, to this tool chest for
resource modules. This blog will cover the purged parameter and show
use-cases through a practical example.&lt;/p&gt;
&lt;p&gt;&lt;img alt="network purge blog one" src="https://ansible.com/images/posts/archive/network-purge-blog-one.png"&gt;&lt;/p&gt;
&lt;p&gt;For this example, we will be using two BGP resource modules to configure
a Cisco network device. We will be using the &lt;code&gt;bgp_global&lt;/code&gt; module
and the &lt;code&gt;bgp_address_family&lt;/code&gt; module. The BGP configuration is split
between these two separate modules to simplify configuration and data
models associated with them.&lt;/p&gt;
&lt;p&gt;Let's start with a data model:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="nt"&gt;bgp_global&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;as_number&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;'65000'&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;bgp&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nt"&gt;log_neighbor_changes&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;true&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nt"&gt;router_id&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="nt"&gt;address&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;192.168.1.1&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;neighbor&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="nt"&gt;activate&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;true&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nt"&gt;address&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;10.200.200.2&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nt"&gt;remote_as&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;65001&lt;/span&gt;
&lt;span class="nt"&gt;bgp_address_family&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;address_family&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="nt"&gt;afi&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;ipv4&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nt"&gt;neighbor&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="nt"&gt;activate&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;true&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="nt"&gt;address&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;10.200.200.2&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nt"&gt;network&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="nt"&gt;address&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;10.25.25.0&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="nt"&gt;mask&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;255.255.255.0&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="nt"&gt;address&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;10.25.26.0&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="nt"&gt;mask&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;255.255.255.0&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="nt"&gt;address&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;10.100.100.0&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="nt"&gt;mask&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;255.255.255.0&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="nt"&gt;address&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;10.200.200.0&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="nt"&gt;mask&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;255.255.255.0&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="nt"&gt;address&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;172.16.0.0&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="nt"&gt;address&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;192.168.1.1&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="nt"&gt;mask&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;255.255.255.255&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;as_number&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;'65000’&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: If you are new to resource modules, you can quickly create
these data models by using the &lt;a href="https://github.com/network-automation/purge_blog_post/blob/main/playbooks/gather_ios_bgp.yaml"&gt;state: gathered&lt;/a&gt;
parameter to read in a brown-field (already configured) network devices
and save that configuration to structured data (e.g. YAML) &lt;/p&gt;
&lt;p&gt;We can push this data model configuration to our Cisco network device
very easily with a simple Ansible Playbook:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="nn"&gt;---&lt;/span&gt;
&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;configure BGP for blog&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;hosts&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;cisco&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;gather_facts&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;false&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;tasks&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;Use the bgp_global resource module&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;cisco.ios.ios_bgp_global&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="nt"&gt;config&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;bgp_global&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}"&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;Use the bgp_address_family&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;cisco.ios.ios_bgp_address_family&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="nt"&gt;config&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;bgp_address_family&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;You can copy this playbook directly from
&lt;a href="https://github.com/network-automation/purge_blog_post/blob/main/playbooks/merge_ios_bgp.yaml"&gt;Github&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;To execute the playbook:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;ansible-playbook&lt;span class="w"&gt; &lt;/span&gt;merge_ios_bgp.yaml
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The output will look similar to the following:&lt;/p&gt;
&lt;p&gt;&lt;img alt="network purge blog two" src="https://ansible.com/images/posts/archive/network-purge-blog-two.png"&gt;&lt;/p&gt;
&lt;p&gt;Finally let's look at the generated configuration on our Cisco IOS network device:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;rtr1#sh&lt;span class="w"&gt; &lt;/span&gt;run&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;s&lt;span class="w"&gt; &lt;/span&gt;router&lt;span class="w"&gt; &lt;/span&gt;bgp
router&lt;span class="w"&gt; &lt;/span&gt;bgp&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;65000&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;bgp&lt;span class="w"&gt; &lt;/span&gt;router-id&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;192&lt;/span&gt;.168.1.1
&lt;span class="w"&gt; &lt;/span&gt;bgp&lt;span class="w"&gt; &lt;/span&gt;log-neighbor-changes
&lt;span class="w"&gt; &lt;/span&gt;neighbor&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;10&lt;/span&gt;.200.200.2&lt;span class="w"&gt; &lt;/span&gt;remote-as&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;65001&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;!
&lt;span class="w"&gt; &lt;/span&gt;address-family&lt;span class="w"&gt; &lt;/span&gt;ipv4
&lt;span class="w"&gt;  &lt;/span&gt;network&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;10&lt;/span&gt;.25.25.0&lt;span class="w"&gt; &lt;/span&gt;mask&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;255&lt;/span&gt;.255.255.0
&lt;span class="w"&gt;  &lt;/span&gt;network&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;10&lt;/span&gt;.25.26.0&lt;span class="w"&gt; &lt;/span&gt;mask&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;255&lt;/span&gt;.255.255.0
&lt;span class="w"&gt;  &lt;/span&gt;network&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;10&lt;/span&gt;.100.100.0&lt;span class="w"&gt; &lt;/span&gt;mask&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;255&lt;/span&gt;.255.255.0
&lt;span class="w"&gt;  &lt;/span&gt;network&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;10&lt;/span&gt;.200.200.0&lt;span class="w"&gt; &lt;/span&gt;mask&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;255&lt;/span&gt;.255.255.0
&lt;span class="w"&gt;  &lt;/span&gt;network&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;172&lt;/span&gt;.16.0.0
&lt;span class="w"&gt;  &lt;/span&gt;network&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;192&lt;/span&gt;.168.1.1&lt;span class="w"&gt; &lt;/span&gt;mask&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;255&lt;/span&gt;.255.255.255
&lt;span class="w"&gt;  &lt;/span&gt;neighbor&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;10&lt;/span&gt;.200.200.2&lt;span class="w"&gt; &lt;/span&gt;activate
&lt;span class="w"&gt; &lt;/span&gt;exit-address-family
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;So finally here is the easy part, using our new &lt;code&gt;state: purged&lt;/code&gt; parameter:
you can delete the entire bgp configuration on a device using one task.
This might be often relevant on lab networks or when you want to start
with a clean-state configuration.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;Use the bgp_global resource module&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;cisco.ios.ios_bgp_global&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;state&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;purged&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;Difference between purged and deleted&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;state: deleted&lt;/code&gt; parameter is very similar, however it has two primary
purposes different than purged. Deleted has the ability to remove the
specified configuration with the config parameter. If no configuration
is specified it will delete that entire resource (e.g. all address
family configuration if using the bgp_address_family module). However,
there are multiple resource modules that make up BGP configuration. This
means you would need multiple modules running &lt;code&gt;state: deleted&lt;/code&gt; to remove
all the BGP configuration. The &lt;code&gt;state: purged&lt;/code&gt; parameter allows you to
use &lt;code&gt;bgp_global&lt;/code&gt; resource module to remove all BGP configuration
simplifying your Ansible Playbooks.&lt;/p&gt;
&lt;p&gt;Now we can execute the playbook and manually check the configuration to
see what it did:&lt;/p&gt;
&lt;p&gt;&lt;img alt="network purge blog three" src="https://ansible.com/images/posts/archive/network-purge-blog-three.png"&gt;&lt;/p&gt;
&lt;p&gt;In the above screenshot (from the Ansible Automation Platform Web UI)
you can see that the playbook ran successfully and the BGP configuration
is now removed.&lt;/p&gt;
&lt;p&gt;Checking the running configuration on the Cisco router will reflect the change:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;rtr1#sh&lt;span class="w"&gt; &lt;/span&gt;run&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;s&lt;span class="w"&gt; &lt;/span&gt;router&lt;span class="w"&gt; &lt;/span&gt;bgp
rtr1#
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;Why would I use one over the other?&lt;/h3&gt;
&lt;p&gt;Many people are automating brownfield networks, or even networks where a
mix of manual changes and automated changes are taking place. You might
want to remove all BGP configuration from multiple devices where you
have no SoT (Source of Truth) setup. This allows a playbook writer to
use one task to destroy just BGP configuration versus a multiple-module
method. This is just another tool in your resource module toolbelt!&lt;/p&gt;
&lt;h3&gt;Where do I go next?&lt;/h3&gt;
&lt;p&gt;All the examples in this blog post are on
&lt;a href="https://github.com/network-automation/purge_blog_post"&gt;Github here&lt;/a&gt;.&lt;/p&gt;</description><guid>https://ansible.com/blog/ansible-network-resource-purge-parameter/</guid><pubDate>Mon, 10 May 2021 00:00:00 GMT</pubDate></item><item><title>Deep dive on VLANS resource modules for network automation</title><link>https://ansible.com/blog/deep-dive-on-vlans-resource-modules-for-network-automation/</link><dc:creator>Sean Cavanaugh</dc:creator><description>&lt;h2&gt;Deep dive on VLANS resource modules for network automation&lt;/h2&gt;
&lt;p&gt;In October of 2019, as part of Red Hat Ansible Engine 2.9, the Ansible
Network Automation team introduced the concept of resource modules. 
These opinionated network modules make network automation easier and
more consistent for those automating various network platforms in
production.  The goal for resource modules was to avoid creating overly
complex jinja2 templates for rendering network configuration. This blog
post goes through the eos_vlans module for the Arista EOS network
platform.  I walk through several examples and describe the use cases
for each state parameter and how we envision these being used in real
world scenarios.&lt;/p&gt;
&lt;p&gt;Before starting let's quickly explain the rationale behind naming of the
network resource modules. Notice for resource modules that configure
VLANs there is a singular form (eos_vlan, ios_vlan, junos_vlan, etc) and
a plural form (eos_vlans, ios_vlans, junos_vlans).  The new resource
modules are the plural form that we are covering today. We have
deprecated the singular form. This was done so that those using existing
network modules would not have their Ansible Playbooks stop working and
have sufficient time to migrate to the new network automation modules.&lt;/p&gt;
&lt;h3&gt;VLAN Example&lt;/h3&gt;
&lt;p&gt;Let's start with an example of the
&lt;a href="https://docs.ansible.com/ansible/latest/modules/eos_vlans_module.html"&gt;eos_vlans&lt;/a&gt;
resource module:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;---
&lt;span class="k"&gt;-&lt;/span&gt; name: add vlans
  hosts: arista
  gather_facts: false
  tasks:
    &lt;span class="k"&gt;-&lt;/span&gt; name: add VLAN configuration
      eos_vlans:
        config:
          &lt;span class="k"&gt;-&lt;/span&gt; name: desktops
            vlan_id: 20
          &lt;span class="k"&gt;-&lt;/span&gt; name: servers
            vlan_id: 30
          &lt;span class="k"&gt;-&lt;/span&gt; name: printers
            vlan_id: 40
          &lt;span class="k"&gt;-&lt;/span&gt; name: DMZ
            vlan_id: 50
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;There is an implicit state parameter which defaults to merged (i.e.
state: merged).  If we run this Ansible Playbook VLANs 20,30,40 and 50
will be merged into the running configuration of any device in the
arista group.  The show vlan output on a new Arista switch will look
like the following:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;rtr2#show&lt;span class="w"&gt; &lt;/span&gt;vlan
VLAN&lt;span class="w"&gt;  &lt;/span&gt;Name&lt;span class="w"&gt;                             &lt;/span&gt;Status&lt;span class="w"&gt;    &lt;/span&gt;Ports
-----&lt;span class="w"&gt; &lt;/span&gt;--------------------------------&lt;span class="w"&gt; &lt;/span&gt;---------&lt;span class="w"&gt; &lt;/span&gt;-------------------------------
&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;default&lt;span class="w"&gt;                          &lt;/span&gt;active
&lt;span class="m"&gt;20&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;desktops&lt;span class="w"&gt;                         &lt;/span&gt;active
&lt;span class="m"&gt;30&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;servers&lt;span class="w"&gt;                          &lt;/span&gt;active
&lt;span class="m"&gt;40&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;printers&lt;span class="w"&gt;                         &lt;/span&gt;active
&lt;span class="m"&gt;50&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;DMZ&lt;span class="w"&gt;                              &lt;/span&gt;active
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;while the running configuration will look like the following:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;rtr2#show&lt;span class="w"&gt; &lt;/span&gt;running-config&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;s&lt;span class="w"&gt; &lt;/span&gt;vlan
vlan&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;20&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;name&lt;span class="w"&gt; &lt;/span&gt;desktops
!
vlan&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;30&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;name&lt;span class="w"&gt; &lt;/span&gt;servers
!
vlan&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;40&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;name&lt;span class="w"&gt; &lt;/span&gt;printers
!
vlan&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;50&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;name&lt;span class="w"&gt; &lt;/span&gt;DMZ
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now let's make a change manually to the network configuration:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;rtr2&lt;span class="o"&gt;(&lt;/span&gt;config&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="c1"&gt;#vlan 100&lt;/span&gt;
rtr2&lt;span class="o"&gt;(&lt;/span&gt;config-vlan-100&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="c1"&gt;#name artisanal_vlan&lt;/span&gt;
rtr2&lt;span class="o"&gt;(&lt;/span&gt;config-vlan-100&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="c1"&gt;#end&lt;/span&gt;
rtr2#wr
Copy&lt;span class="w"&gt; &lt;/span&gt;completed&lt;span class="w"&gt; &lt;/span&gt;successfully.
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;If I re-run the Ansible Playbook it returns with changed=0 because it
only cares about the VLANs 20, 30, 40 and 50. It won't remove VLAN 100
because we have the state parameter set to merged by default, so it only
will merged the data model it knows about. It is just enforcing
configuration policy of the VLANs I am sending.&lt;/p&gt;
&lt;h3&gt;Using the 'state' parameter&lt;/h3&gt;
&lt;p&gt;What happens if I change the state parameter to replaced?  Just change
the previous example to the following:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;---
&lt;span class="k"&gt;-&lt;/span&gt; name: add vlans
  hosts: arista
  gather_facts: false
  tasks:
    &lt;span class="k"&gt;-&lt;/span&gt; name: add VLAN configuration
      eos_vlans:
        state: replaced
        config:
          &lt;span class="k"&gt;-&lt;/span&gt; name: desktops
            vlan_id: 20
          &lt;span class="k"&gt;-&lt;/span&gt; name: servers
            vlan_id: 30
          &lt;span class="k"&gt;-&lt;/span&gt; name: printers
            vlan_id: 40
          &lt;span class="k"&gt;-&lt;/span&gt; name: DMZ
            vlan_id: 50
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The Ansible Playbook ran just like before with changed=0. Can we tell if
it removed the artisanal_vlan 100?&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;rtr2#show&lt;span class="w"&gt; &lt;/span&gt;vlan
VLAN&lt;span class="w"&gt;  &lt;/span&gt;Name&lt;span class="w"&gt;                             &lt;/span&gt;Status&lt;span class="w"&gt;    &lt;/span&gt;Ports
-----&lt;span class="w"&gt; &lt;/span&gt;--------------------------------&lt;span class="w"&gt; &lt;/span&gt;---------&lt;span class="w"&gt; &lt;/span&gt;-------------------------------
&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;default&lt;span class="w"&gt;                          &lt;/span&gt;active
&lt;span class="m"&gt;20&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;desktops&lt;span class="w"&gt;                         &lt;/span&gt;active
&lt;span class="m"&gt;30&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;servers&lt;span class="w"&gt;                          &lt;/span&gt;active
&lt;span class="m"&gt;40&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;printers&lt;span class="w"&gt;                         &lt;/span&gt;active
&lt;span class="m"&gt;50&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;DMZ&lt;span class="w"&gt;                              &lt;/span&gt;active
&lt;span class="m"&gt;100&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;artisanal_vlan&lt;span class="w"&gt;                   &lt;/span&gt;active
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Nope! The goal of resource modules is to update existing resources to
match the existing data model. Since our data model (the key, value
pairs that represent the VLANs, which are passed under the config
parameter in the playbook) only includes VLANs 20, 30, 40 and 50 the
eos_vlans module only updates parameters relevant to those particular
VLANs.&lt;/p&gt;
&lt;p&gt;Why would I use this versus a merged? The major difference between a
merged and a replaced is that a merged just makes sure the commands are
present that are represented within the data model, whereas the replaced
parameter makes your resource match the data model. Let\'s look at the
eos_vlans module to see what it considers as part of the vlans resource.&lt;/p&gt;
&lt;p&gt;There are three parameters currently used for the &lt;strong&gt;vlans&lt;/strong&gt; resource:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;name&lt;/li&gt;
&lt;li&gt;state (active or suspend)&lt;/li&gt;
&lt;li&gt;vlan_id (range between 1-4094)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let's look at the following example:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Data Model Sent&lt;/strong&gt;&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;desktops&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;vlan_id&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;20&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Existing Arista Config&lt;/strong&gt;&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;vlan&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;200&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;state&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;suspend&lt;/span&gt;
!
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This is how merged compares to replaced:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;merged&lt;/strong&gt;&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;vlan&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;200&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;name&lt;span class="w"&gt; &lt;/span&gt;desktops
&lt;span class="w"&gt;  &lt;/span&gt;state&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;suspend&lt;/span&gt;
!
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;replaced&lt;/strong&gt;&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;vlan&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;200&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;name&lt;span class="w"&gt; &lt;/span&gt;desktops
!
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The replaced parameter enforces the data model on the network device for
each configured VLAN.  In the example above it will remove the &lt;code&gt;state suspend&lt;/code&gt;
because it is not within the data model.  To think of this
another way, the replaced parameter is aware of commands that shouldn't
be there as well as what should.&lt;/p&gt;
&lt;h3&gt;Using the overridden state parameter&lt;/h3&gt;
&lt;p&gt;What happens if I change the state parameter to overridden?  Just change
the original example to the following:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;---
&lt;span class="k"&gt;-&lt;/span&gt; name: add vlans
  hosts: arista
  gather_facts: false
  tasks:
    &lt;span class="k"&gt;-&lt;/span&gt; name: add VLAN configuration
      eos_vlans:
        state: overridden
        config:
          &lt;span class="k"&gt;-&lt;/span&gt; name: desktops
            vlan_id: 20
          &lt;span class="k"&gt;-&lt;/span&gt; name: servers
            vlan_id: 30
          &lt;span class="k"&gt;-&lt;/span&gt; name: printers
            vlan_id: 40
          &lt;span class="k"&gt;-&lt;/span&gt; name: DMZ
            vlan_id: 50
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now run the Ansible Playbook:&lt;/p&gt;
&lt;p&gt;&lt;img alt="screenshot" src="https://ansible.com/images/posts/archive/sean-blog-two.png"&gt;&lt;/p&gt;
&lt;p&gt;The Ansible Playbook now has changed=1.  But did it remove the
artisanal_vlan 100?&lt;/p&gt;
&lt;p&gt;Logging into one of the Arista devices confirms it did!&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;rtr2#show&lt;span class="w"&gt; &lt;/span&gt;vlan
VLAN&lt;span class="w"&gt;  &lt;/span&gt;Name&lt;span class="w"&gt;                             &lt;/span&gt;Status&lt;span class="w"&gt;    &lt;/span&gt;Ports
-----&lt;span class="w"&gt; &lt;/span&gt;--------------------------------&lt;span class="w"&gt; &lt;/span&gt;---------&lt;span class="w"&gt; &lt;/span&gt;-------------------------------
&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;default&lt;span class="w"&gt;                          &lt;/span&gt;active
&lt;span class="m"&gt;20&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;desktops&lt;span class="w"&gt;                         &lt;/span&gt;active
&lt;span class="m"&gt;30&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;servers&lt;span class="w"&gt;                          &lt;/span&gt;active
&lt;span class="m"&gt;40&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;printers&lt;span class="w"&gt;                         &lt;/span&gt;active
&lt;span class="m"&gt;50&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;DMZ&lt;span class="w"&gt;                              &lt;/span&gt;active
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The overridden parameter will enforce all &lt;strong&gt;vlans&lt;/strong&gt; resources to the
data model.  This means it removes VLANs that are not defined in the
data model being sent.&lt;/p&gt;
&lt;h3&gt;Takeaways&lt;/h3&gt;
&lt;p&gt;There are currently three ways to push configuration using resource
modules.  These are the merged, replaced and overridden parameters.
These allow much more flexibility for network engineers to adopt
automation in incremental steps.  We realize that most folks will start
with the merged parameter as they gain familiarity with the new resource
module concepts. Over time organizations will move towards the
overridden parameter as they adopt a standard SoT (source of truth) for
their data models, wherever they reside.&lt;/p&gt;</description><guid>https://ansible.com/blog/deep-dive-on-vlans-resource-modules-for-network-automation/</guid><pubDate>Wed, 19 Feb 2020 00:00:00 GMT</pubDate></item><item><title>Agnostic network automation examples with Ansible and NRE Labs</title><link>https://ansible.com/blog/agnostic-network-automation-examples-with-ansible-and-juniper-nre-labs/</link><dc:creator>Sean Cavanaugh</dc:creator><description>&lt;h2&gt;Agnostic network automation examples with Ansible and NRE Labs&lt;/h2&gt;
&lt;p&gt;On February 10th, The NRE Labs project launched four Ansible Network
Automation exercises, made possible by Red Hat and Juniper Networks. 
This blog post covers job responsibilities of an NRE, the goal of NRE
Labs, and a quick overview of new exercises and the concepts Red Hat and
Juniper are jointly demonstrating.  The intended audience for these
initial exercises is someone new to Ansible Network Automation with
limited experience with Ansible and network automation. The initial
network topology for these exercises covers Ansible automating Juniper
Junos OS and Cumulus VX virtual network instances.&lt;/p&gt;
&lt;h2&gt;About NRE Labs&lt;/h2&gt;
&lt;p&gt;Juniper has defined an NRE or &lt;a href="https://www.juniper.net/us/en/products-services/what-is/nre/"&gt;network reliability engineer&lt;/a&gt;,
as someone that can help an organization with modern network
automation.  This concept has many different names including DevOps for
networks, NetDevOps, or simply just network automation.  Juniper and Red
Hat realized that this skill set is new to many traditional network
engineers and worked together to create online exercises to help folks
get started with Ansible Network Automation.  Specifically, Juniper
worked with us through NRE Labs, a project they started and co-sponsor
that offers a no-strings-attached, community-centered initiative to
bring the skills of automation within reach for everyone. This works
through short, simple exercises within your browser.  You can find NRE
Labs at the following location:
&lt;a href="https://nrelabs.io/"&gt;https://nrelabs.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;With Red Hat Ansible Engine 2.9 we introduced the concept of resource modules
and native fact gathering, so I wanted to make sure that these exercises
covered the latest and greatest aspects of Ansible Network Automation to
make this turn key for network engineers.  If you are new to resource
modules, native fact gathering or even just the Juniper network platform
I think it is worth skimming through these exercises!&lt;/p&gt;
&lt;p&gt;Lets begin with a network diagram:&lt;/p&gt;
&lt;p&gt;&lt;img alt="NRE diagram" src="https://ansible.com/images/posts/archive/NRE_diagram.png"&gt;&lt;/p&gt;
&lt;p&gt;Each of the four exercises has a different set of objectives outlined,
step-by-step instructions and takeaways for your Ansible knowledge.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://go.nrelabs.io/labs/?lessonSlug=ansible-network-automation&amp;amp;lessonStage=0"&gt;Exercise 1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This exercise covers what an Ansible INI-based inventory looks like, the
Ansible configuration file (ansible.cfg) and running an Ansible Playbook
for enabling NETCONF on Juniper Junos.  This exercise also illustrates
the concept of idempotency and why it is important for network
automation.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://go.nrelabs.io/labs/?lessonSlug=ansible-network-automation&amp;amp;lessonStage=1"&gt;Exercise 2&lt;/a&gt; - Facts&lt;/p&gt;
&lt;p&gt;This exercise covers native fact gathering (using gather_facts: True)
and using the debug module.  We show how to quickly print serial numbers
and version numbers to the terminal window using just three tasks.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://go.nrelabs.io/labs/?lessonSlug=ansible-network-automation&amp;amp;lessonStage=2"&gt;Exercise 3&lt;/a&gt; - Resource Facts&lt;/p&gt;
&lt;p&gt;This exercise covers more in depth fact gathering using the junos_facts
module in conjunction with the new gather_network_resources parameter. 
This allows the junos_facts module to gather facts from any resource
module to read in network configurations and store them as YAML/JSON. 
This exercise also covers converting these facts into a structured YAML
file.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://go.nrelabs.io/labs/?lessonSlug=ansible-network-automation&amp;amp;lessonStage=3"&gt;Exercise 4&lt;/a&gt; - Network Configuration Templates&lt;/p&gt;
&lt;p&gt;This exercise covers using and understanding host variables, using
simple Jinja2 templating, using the junos_config module for Juniper
Junos and the template module for Cumulus Linux.  The overarching goal
of this exercise is using Ansible Network Automation to create an OSPF
adjacency between the Cumulus VX device cvx11 and the Juniper Junos
device vqfx1.&lt;/p&gt;</description><guid>https://ansible.com/blog/agnostic-network-automation-examples-with-ansible-and-juniper-nre-labs/</guid><pubDate>Mon, 10 Feb 2020 00:00:00 GMT</pubDate></item><item><title>Rebooting Network Devices with Ansible</title><link>https://ansible.com/blog/rebooting-network-devices-with-ansible/</link><dc:creator>Sean Cavanaugh</dc:creator><description>&lt;h2&gt;Rebooting Network Devices with Ansible&lt;/h2&gt;
&lt;p&gt;With the Red Hat Ansible Automation Platform release in November, we
released over 50 network resource modules to help make automating
network devices easier and more turn-key for network engineers.  In
addition to the new resource modules, Andrius also discussed fact
gathering enhancements in his blog post,
which means with every new resource module, users gain increased fact
coverage for network devices.  For this blog post I want to cover
another cool enhancement that may have gone unnoticed. This is the
ability for network devices to make use of the
&lt;a href="https://docs.ansible.com/ansible/latest/modules/wait_for_connection_module.html"&gt;wait_for_connection&lt;/a&gt;
module.  If you are a network engineer that has operational Ansible
Playbooks that need to reboot devices or take them offline, this module
will help you make more programmatic playbooks to handle disconnects. 
By leveraging wait_for_connection network automation playbooks can look
and behave more like playbooks for Linux or Windows hosts.&lt;/p&gt;
&lt;h3&gt;Comparing wait_for and wait_for_connection&lt;/h3&gt;
&lt;p&gt;There are two great modules that can wait for a condition to be met,
&lt;a href="https://docs.ansible.com/ansible/latest/modules/wait_for_module.html"&gt;wait_for&lt;/a&gt;
and the wait_for_connection.  I highly recommend against using the pause
module if you can get away with it, and I equate it to using a
programming equivalent of a sleep within an Ansible Playbook.  Using
either of these two wait_for modules is superior to random pauses within
your Ansible Playbook because they are a more programmatic solution that
is more adaptable to devices taking different amounts of time to
complete a task.  The other problem with the pause module is that using
prompts does not work within Ansible Tower. A much better solution for
human interaction would be to use an Ansible Tower workflow with an
&lt;a href="https://docs.ansible.com/ansible-tower/latest/html/userguide/workflow_templates.html#approval-nodes"&gt;approval node&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The wait_for module can wait until a path on a filesystem exists, or
until a port is active again.  This works great for most reboot use
cases, except for when a system is not able to be logged into
immediately after the port is up.  The wait_for_connection extends the
functionality of the wait_for use case a bit further. The
wait_for_connection module will make sure that Ansible can log back into
the device and receive the appropriate prompts before finishing
completing the task. For Linux and Windows hosts it will use the ping or
win_ping module, for network devices it will make sure the
&lt;a href="https://docs.ansible.com/ansible/latest/plugins/connection.html"&gt;connection plugin&lt;/a&gt;
that was last used can fully connect to the device.  At the time of this
blog post this only works with the &lt;code&gt;network_cli&lt;/code&gt; connection plugin.  This
means that subsequent tasks can begin operating as intended as soon as
wait_for_connection completes versus where wait_for just knows that port
is open.&lt;/p&gt;
&lt;h3&gt;Dealing with prompts&lt;/h3&gt;
&lt;p&gt;With networking devices when we perform operational tasks such as a
reboot, there is often a prompt to confirm that you want to take an
action.&lt;/p&gt;
&lt;p&gt;For example on a Juniper vSRX device:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;admin@rtr3&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;request&lt;span class="w"&gt; &lt;/span&gt;system&lt;span class="w"&gt; &lt;/span&gt;reboot
Reboot&lt;span class="w"&gt; &lt;/span&gt;the&lt;span class="w"&gt; &lt;/span&gt;system&lt;span class="w"&gt; &lt;/span&gt;?&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;yes,no&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;no&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The user has to confirm the reload to be able to proceed.
Something I neglected to cover on my deep dive with &lt;code&gt;cli_command&lt;/code&gt; blog was that &lt;a href="https://docs.ansible.com/ansible/latest/modules/cli_command_module.html"&gt;cli_command module&lt;/a&gt; can handle prompts.
The &lt;code&gt;cli_command&lt;/code&gt; module can even handle multiple prompts!
For this example the Cisco router had not saved its config, and we are performing a reload.
First the Cisco router will alert me that the System configuration has been modified, and ask me if I want to save this before I lose my running-configuration:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;rtr1#reload

System&lt;span class="w"&gt; &lt;/span&gt;configuration&lt;span class="w"&gt; &lt;/span&gt;has&lt;span class="w"&gt; &lt;/span&gt;been&lt;span class="w"&gt; &lt;/span&gt;modified.&lt;span class="w"&gt; &lt;/span&gt;Save?&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;yes/no&lt;span class="o"&gt;]&lt;/span&gt;:
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;After confirming &lt;code&gt;yes&lt;/code&gt; or &lt;code&gt;no&lt;/code&gt;, you will receive a second prompt:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;Proceed&lt;span class="w"&gt; &lt;/span&gt;with&lt;span class="w"&gt; &lt;/span&gt;reload?&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;confirm&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;We need to build a task that can handle both prompts using the &lt;code&gt;cli_command&lt;/code&gt; module:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="nn"&gt;---&lt;/span&gt;
&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;reboot ios device&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;cli_command&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;command&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;reload&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;prompt&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;Save?&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;confirm&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;answer&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;y&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;y&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The above task will answer yes to both prompts, saving the config and reloading the device.
The list for prompt answer and the list for answer must match and be in the same order.
This means that the answer for &lt;code&gt;prompt[0]&lt;/code&gt; must be &lt;code&gt;answer[0]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If you want to see a more detailed example of handling multiple prompts,
&lt;a href="https://github.com/ansible/workshops/blob/master/provisioner/roles/configure_routers/tasks/juniper_default.yml"&gt;here is an example of a password reset on a Juniper vSRX device&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Using reset_connection in combination&lt;/h3&gt;
&lt;p&gt;Now that you understand how to reboot the device with cli_command we can combine that with the wait_for_connection to create a reusable Ansible Playbook.
However, we need to add one more task, a &lt;a href="https://docs.ansible.com/ansible/latest/modules/meta_module.html"&gt;meta: reset_connection&lt;/a&gt; to make this work programmatically.  &lt;/p&gt;
&lt;p&gt;We need to make sure the current connection to the network device is
closed so that the socket can be reestablished to the network device
after the reboot takes place.  If the connection is not closed and the
command timeout is longer than the time it takes to reboot, the
persistent connection will attempt to reuse the closed SSH connection
resulting in the failure "Socket is closed". A correct Ansible Playbook
looks like this:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;reboot task (this is a snippet, full task removed for brevity)&lt;/span&gt;

&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;reset the connection&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;meta&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;reset_connection&lt;/span&gt;

&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;Wait for the network device to reload&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;wait_for_connection&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;delay&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;10&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now we have an Ansible Playbook that can reconnect to network devices after a reboot is issued!
For a full example please &lt;a href="https://gist.github.com/IPvSean/56f6522cc73629984d3e47013240a1fa"&gt;refer to this reboot.yml&lt;/a&gt; Ansible Playbook for Arista vEOS network devices.&lt;/p&gt;
&lt;h3&gt;Where to go next?&lt;/h3&gt;
&lt;p&gt;This blog helped outline how to create reusable Ansible Playbooks for
rebooting network devices.  One of the next steps is obviously building
out an Ansible Role that can reboot multiple network platforms.  I have
gone ahead and &lt;a href="https://github.com/network-automation/tower_workshop/blob/master/network_reload.yml"&gt;created one and uploaded it to Github here&lt;/a&gt;. 
This role will work on Juniper Junos, Cisco IOS and Arista EOS devices
and can be easily modified to handle many more network operating systems.&lt;/p&gt;</description><guid>https://ansible.com/blog/rebooting-network-devices-with-ansible/</guid><pubDate>Fri, 20 Dec 2019 00:00:00 GMT</pubDate></item><item><title>Three quick ways to move your Ansible inventory into Red Hat Ansible Tower</title><link>https://ansible.com/blog/three-quick-ways-to-move-your-ansible-inventory-into-red-hat-ansible-tower/</link><dc:creator>Sean Cavanaugh</dc:creator><description>&lt;h2&gt;Three quick ways to move your Ansible inventory into Red Hat Ansible Tower&lt;/h2&gt;
&lt;p&gt;If you've been using Ansible at the command line for a while, you
probably have a lot of servers, network devices, and other target nodes
listed in your inventory. You know that Red Hat Ansible Tower makes it
easier for everyone on your team to run your Ansible Playbooks. So
you've thought about using Ansible Tower to take your automation to the
next level, but you want to retain all the data and variables in your
existing inventory file or directory. Are you worried about transferring
your inventory from command-line use to Ansible Tower? Let me show you
how easy it is to import your existing Ansible inventory into Ansible
Tower!&lt;/p&gt;
&lt;p&gt;This blog covers three quick and effective ways to connect your existing
Ansible inventory into Ansible Tower:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Migrating an inventory file from the Ansible Tower control node
    (awx-manage)&lt;/li&gt;
&lt;li&gt;Migrating an inventory file from anywhere with a playbook&lt;/li&gt;
&lt;li&gt;Setting Tower to access a git source-controlled inventory file&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If you're using &lt;a href="https://docs.ansible.com/ansible-tower/latest/html/userguide/inventories.html"&gt;dynamic inventory&lt;/a&gt;,
you don't need to import your inventory into Ansible Tower. Dynamic
inventory retrieves your inventory from an existing source. With dynamic
inventory, you don't need to manage an inventory file at all, you just
retrieve the latest and most up-to-date listing every time. Ansible
&lt;a href="https://docs.ansible.com/ansible-tower/latest/html/userguide/inventories.html#credential-sources"&gt;Tower seamlessly integrates&lt;/a&gt;
with popular dynamic inventory sources including Red Hat OpenStack
Platform, Red Hat Satellite, public cloud platforms (Amazon Web
Services/AWS, Google Compute Engine/GCE, Microsoft Azure), and
virtualization solutions like Red Hat Virtualization and VMware vCenter.
You can use scripts to integrate Infoblox DDI and ServiceNow CMDB for
dynamic inventory in Ansible Tower as well.&lt;/p&gt;
&lt;p&gt;NOTE: This blog does not cover the importing of Ansible Playbooks or
Ansible Tower workflows into Ansible Tower and is strictly focused on
Ansible inventory portability.&lt;/p&gt;
&lt;h3&gt;Migrating an inventory file from the Ansible Tower control node (awx-manage)&lt;/h3&gt;
&lt;p&gt;The command line tool
&lt;a href="https://docs.ansible.com/ansible-tower/latest/html/administration/tower-manage.html"&gt;awx-manage&lt;/a&gt;,
which comes with your Ansible Tower installation, is a simple and
effective tool to import your inventory. Using awx-manage makes the most
sense when your inventory is a flat file in YAML or ini format that
already lives on your Ansible control node. You run the command and
point to your existing inventory file then Ansible Tower will be loaded
with all the hosts.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Using the WebUI login to Ansible Tower and create an empty
    inventory.&lt;/p&gt;
&lt;p&gt;&lt;img alt="inventory" src="https://ansible.com/images/posts/archive/inventory.gif"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Login via SSH to your Ansible Tower control node (This is the Linux
    machine that has Ansible Tower installed on it).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Locate the flat-file that represents your Ansible inventory.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Run the awx-manage inventory_import command like this&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;awx&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;manage&lt;/span&gt; &lt;span class="n"&gt;inventory_import&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;source&lt;/span&gt;&lt;span class="o"&gt;=/&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;hosts&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;inventory&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"My Inventory"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;On the terminal window you will receive some output similar to the
following:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="mf"&gt;1.387&lt;/span&gt; &lt;span class="n"&gt;INFO&lt;/span&gt; &lt;span class="n"&gt;Updating&lt;/span&gt; &lt;span class="n"&gt;inventory&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;My&lt;/span&gt; &lt;span class="n"&gt;Inventory&lt;/span&gt;
&lt;span class="mf"&gt;1.475&lt;/span&gt; &lt;span class="n"&gt;INFO&lt;/span&gt; &lt;span class="n"&gt;Reading&lt;/span&gt; &lt;span class="n"&gt;Ansible&lt;/span&gt; &lt;span class="n"&gt;inventory&lt;/span&gt; &lt;span class="n"&gt;source&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;hosts&lt;/span&gt;
&lt;span class="mf"&gt;2.119&lt;/span&gt; &lt;span class="n"&gt;INFO&lt;/span&gt; &lt;span class="n"&gt;Processing&lt;/span&gt; &lt;span class="n"&gt;JSON&lt;/span&gt; &lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="mf"&gt;2.120&lt;/span&gt; &lt;span class="n"&gt;INFO&lt;/span&gt; &lt;span class="n"&gt;Loaded&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="n"&gt;groups&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="n"&gt;hosts&lt;/span&gt;
&lt;span class="mf"&gt;2.329&lt;/span&gt; &lt;span class="n"&gt;INFO&lt;/span&gt; &lt;span class="n"&gt;Inventory&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;completed&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;My&lt;/span&gt; &lt;span class="n"&gt;Inventory&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="mf"&gt;0.9&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Now when you login via the WebUI you will see all the hosts under
    the inventory&lt;/p&gt;
&lt;p&gt;&lt;img alt="loaded_inventory" src="https://ansible.com/images/posts/archive/loaded_inventory.gif"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The awx-manage command line tool is very simple and fast. It only took
me a couple seconds to take my existing inventory and import it into
Ansible Tower.&lt;/p&gt;
&lt;p&gt;For teams that use Ansible Tower to run playbooks, but manage inventory
outside of Ansible Tower, importing with awx-manage is not the best
option, since you would need to re-import the flat-file inventory every
time a change is made to your inventory file. If your team will continue
to manage inventory outside of Ansible Tower, you probably want to use
the GitHub option described below.&lt;/p&gt;
&lt;h3&gt;Migrating an inventory file from anywhere with a playbook&lt;/h3&gt;
&lt;p&gt;You can use the &lt;a href="https://docs.ansible.com/ansible/latest/modules/list_of_web_infrastructure_modules.html#ansible-tower"&gt;Ansible Tower modules&lt;/a&gt;
to automate the transfer of your inventory into Ansible Tower. These
modules make it possible to use Ansible Playbooks to automate and manage
everything, including inventory, in your Ansible Tower instance. There
is a &lt;a href="https://docs.ansible.com/ansible/latest/modules/tower_inventory_module.html#tower-inventory-module"&gt;tower_inventory module&lt;/a&gt;
that will let us create an inventory, and there is a &lt;a href="https://docs.ansible.com/ansible/latest/modules/tower_host_module.html#tower-host-module"&gt;tower_host module&lt;/a&gt;
that lets us add a host to an existing inventory. Assume that we already
created an inventory called "Network Routers" and I will build an
Ansible Playbook to add all my routers in the group routers to that
inventory using the tower_host module. The Ansible Playbook will look
like this:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;NETWORK SETUP&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="nt"&gt;hosts&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;routers&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="nt"&gt;connection&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;local&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="nt"&gt;become&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;yes&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="nt"&gt;gather_facts&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;no&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="nt"&gt;tasks&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;ADD NETWORK HOSTS INTO TOWER&lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="nt"&gt;tower_host&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;inventory_hostname&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;}}"&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="nt"&gt;inventory&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"Network&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;Routers"&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="nt"&gt;tower_username&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;admin&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="nt"&gt;tower_password&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;ansible&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="nt"&gt;tower_host&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;https://localhost&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="nt"&gt;variables&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;                  &lt;/span&gt;&lt;span class="nt"&gt;ansible_network_os&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{ansible_network_os}}"&lt;/span&gt;
&lt;span class="w"&gt;                  &lt;/span&gt;&lt;span class="nt"&gt;ansible_host&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{ansible_host}}"&lt;/span&gt;
&lt;span class="w"&gt;                  &lt;/span&gt;&lt;span class="nt"&gt;ansible_user&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{ansible_user}}"&lt;/span&gt;
&lt;span class="w"&gt;                  &lt;/span&gt;&lt;span class="nt"&gt;ansible_connection&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{ansible_connection}}"&lt;/span&gt;
&lt;span class="w"&gt;                  &lt;/span&gt;&lt;span class="nt"&gt;ansible_become&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;yes&lt;/span&gt;
&lt;span class="w"&gt;                  &lt;/span&gt;&lt;span class="nt"&gt;ansible_become_method&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;enable&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The Ansible Playbook will add all devices in the group routers
simultaneously. The playbook output will look similar to this: &lt;/p&gt;
&lt;p&gt;&lt;img alt="Ansible-Playbook" src="https://ansible.com/images/posts/archive/Ansible-Playbook.png"&gt;&lt;/p&gt;
&lt;p&gt;The advantage of this method is you don't have to be on the control
node, you can run the Ansible Playbook from anywhere. Like the
awx-manage option, transferring your inventory to Ansible Tower with an
Ansible Playbook works well only if you will manage your inventory in
Tower in future. These two methods are migration strategies to Tower.
Ansible If you use dynamic inventory or source control to manage
inventory, you'd have to re-run the playbook for Ansible Tower every
time you changed your inventory.&lt;/p&gt;
&lt;h3&gt;Setting Tower to access a git source-controlled inventory file&lt;/h3&gt;
&lt;p&gt;The final method I want to cover in this post is using source control to
manage my inventory. I have a flat-file inventory file stored in a
Github repo. I made an example repo to illustrate this concept here:&lt;/p&gt;
&lt;p&gt;https://github.com/ipvsean/sample_inventory&lt;/p&gt;
&lt;p&gt;Unlike the previous two methods, this is not meant as a migration
strategy, but a more permanent way to manage your Ansible inventory
using git and source control. Inventory can be managed in Github and
Ansible Tower can simply reflect those changes. &lt;/p&gt;
&lt;p&gt;First we need to create an Ansible Tower Project. An Ansible Tower
Project is how we can sync Ansible Tower to source code management (SCM)
system supported by Ansible Tower, including Git, Subversion, and
Mercurial. I will add a Project named Sean's Github, set the SCM Type to
Git, and put the SCM URL I listed above.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Tower project ui" src="https://ansible.com/images/posts/archive/tower-project-ui.gif"&gt;&lt;/p&gt;
&lt;p&gt;Now I need to create an Inventory that will use this Ansible Tower
project. I will:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Create an inventory called Sean Github Inventory.&lt;/li&gt;
&lt;li&gt;Add a Source called Sean Github Source, and choose the Ansible Tower
    Project previously created (named Sean's Github).&lt;/li&gt;
&lt;li&gt;As soon as the Project is selected a drop down menu will appear and
    allow us to point directly the hosts flat-file.&lt;/li&gt;
&lt;li&gt;Once you create the source you can sync it using the circular arrow
    sync button. The hosts and groups will automatically show up under
    the hosts button as shown in the animation below.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="github_inventory" src="https://ansible.com/images/posts/archive/github_inventory.gif"&gt;&lt;/p&gt;
&lt;p&gt;Using source control for managing inventory is popular with Ansible
Tower users and can scale really well.&lt;/p&gt;</description><guid>https://ansible.com/blog/three-quick-ways-to-move-your-ansible-inventory-into-red-hat-ansible-tower/</guid><pubDate>Mon, 18 Mar 2019 00:00:00 GMT</pubDate></item></channel></rss>