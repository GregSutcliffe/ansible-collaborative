<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Ansible Collaborative (Posts by Roger Lopez)</title><link>https://ansible.com/</link><description></description><atom:link href="https://ansible.com/authors/roger-lopez.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2024 &lt;a href="mailto:website@ansible.community"&gt;Ansible Collaborative, et al&lt;/a&gt; </copyright><lastBuildDate>Thu, 21 Mar 2024 14:38:23 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Using Ansible and GitOps to Manage the Lifecycle of a Containerized Application</title><link>https://ansible.com/blog/taking-automation-to-the-next-level-using-ansible-gitops-to-manage-the-lifecycle-of-a-containerized-application/</link><dc:creator>Roger Lopez</dc:creator><description>&lt;h2&gt;Using Ansible and GitOps to Manage the Lifecycle of a Containerized Application&lt;/h2&gt;
&lt;p&gt;One of the great advantages of combining GitOps with Ansible is that
you get to streamline the automation delivery and the lifecycle of a
containerized application.&lt;/p&gt;
&lt;p&gt;With the abilities of GitOps we get to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Standardize configurations of our applications.&lt;/li&gt;
&lt;li&gt;Inherit the benefits of version control of our
    configurations.&lt;/li&gt;
&lt;li&gt;Easily track changes of the configuration settings making fixing
    issues easier.&lt;/li&gt;
&lt;li&gt;Have one source of truth for our
    applications.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Combine the above with Ansible and you have everything you need to
accomplish configuration consistency for a containerized app anywhere
that you automate. &lt;/p&gt;
&lt;p&gt;That leads us to, "how do we combine Ansible and GitOps to manage the
lifecycle of a containerized application?"&lt;/p&gt;
&lt;p&gt;Simple. By creating an Ansible workflow that is associated with a Git
webhook that is part of my application's repository.&lt;/p&gt;
&lt;p&gt;What is a Git webhook you ask?&lt;/p&gt;
&lt;p&gt;Git webhooks are defined as a method to deliver notifications to an
external web server whenever certain actions occur on a
repository.&lt;/p&gt;
&lt;p&gt;For example, when a repository is updated, this could trigger an event
that could trigger CI builds, deploy an environment, or in our case,
modify the configuration of our containerized
application. &lt;/p&gt;
&lt;p&gt;A webhook provides the ability to execute specified commands between
apps over the web. Automation controller provides webhook integration
with GitHub and GitLab, but for the purposes of this blog we will be
integrating with GitHub. &lt;/p&gt;
&lt;p&gt;In the following sections of this blog, I'm going to provide the
step-by-step process to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Setup your Git webhook (using GitHub).&lt;/li&gt;
&lt;li&gt;Setting up an Ansible workflow that triggers via push events from
    your GitHub repository.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Create a GitHub personal access token&lt;/h3&gt;
&lt;p&gt;The GitHub personal access token (PAT) is one of the credentials needed
to associate the Ansible workflow with your Git
repository.&lt;/p&gt;
&lt;p&gt;Generate a personal access token (PAT) for use with automation
controller.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;In the profile settings of your GitHub account, click &lt;strong&gt;Settings&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Below the Personal settings, click &lt;strong&gt;Developer Settings&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;In the Developer settings, click &lt;strong&gt;Personal access tokens&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;From the Personal access tokens screen, click &lt;strong&gt;Generate new token&lt;/strong&gt; button.&lt;/li&gt;
&lt;li&gt;When prompted, enter your GitHub account password to continue.&lt;/li&gt;
&lt;li&gt;In the &lt;strong&gt;Note&lt;/strong&gt; field, enter a brief description about what this PAT will be used for.&lt;/li&gt;
&lt;li&gt;In the &lt;strong&gt;Expiration&lt;/strong&gt; drop down, select &lt;strong&gt;No expiration&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;In the &lt;strong&gt;Scope&lt;/strong&gt; fields, automation controller webhook only needs repo scope access, with the exception of invites. For information about other scopes, click the link right above the table to access the docs.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="example personal access token" src="https://ansible.com/images/posts/archive/gh-app-demo-at.png"&gt;&lt;/p&gt;
&lt;p&gt;Click the &lt;strong&gt;Generate Token&lt;/strong&gt; button at the bottom of the page.&lt;/p&gt;
&lt;p&gt;Once we have our PAT in place, the next step is to create a Git
repository that will be triggered by our GitHub webhooks when changes
are made to the repository.&lt;/p&gt;
&lt;p&gt;For the purposes of this blog, I'll be using my
&lt;a href="https://github.com/rlopez133/app_demo"&gt;App Demo Repository&lt;/a&gt;.
Feel free to use your own or fork this repository to follow along. &lt;/p&gt;
&lt;h3&gt;Familiarizing ourselves with the App Demo Repository&lt;/h3&gt;
&lt;p&gt;The App Demo Repository is fairly simplistic, as it
contains:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;container_playbook.yml&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;group_vars/all.yml&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;requirements.yml&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The container_playbook.yml is a simple playbook that creates a color
container, starts it on a specific port and sets two environment
variables, &lt;code&gt;APP_COLOR&lt;/code&gt; and &lt;code&gt;tree&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;A sample of that &lt;code&gt;container_playbook.yml&lt;/code&gt;:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="o"&gt;---&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;Playbook&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;to&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;setup&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;prereqs&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nx"&gt;hosts&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;all&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nx"&gt;become&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nx"&gt;tasks&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;Create&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;color&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;container&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="nx"&gt;containers&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;podman&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;podman_container&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;colors&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nx"&gt;image&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;docker&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;io&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nx"&gt;mmumshad&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nx"&gt;simple&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nx"&gt;webapp&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nx"&gt;color&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nx"&gt;latest&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nx"&gt;state&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;started&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nx"&gt;network&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;host&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nx"&gt;ports&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{ host_port }}:{{ container_port }}"&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nx"&gt;env&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="nx"&gt;APP_COLOR&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{ color }}"&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="nx"&gt;tree&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"{{ tree }}"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code&gt;group_vars/all.yml&lt;/code&gt; is where I'll be making modifications to my
Podman container that will trigger changes to the container.&lt;/p&gt;
&lt;p&gt;A sample of that &lt;code&gt;group_vars/all.yml&lt;/code&gt; file:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;color: "BLUE"
tree: "trunk"
host_port: 8080
container_port: 8080
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Finally, we have the &lt;code&gt;requirements.yml&lt;/code&gt; file that ensures we have the
containers.podman collection available to use within the playbook. &lt;/p&gt;
&lt;p&gt;A sample of the &lt;code&gt;requirements.yml&lt;/code&gt;:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;collections:
- name: containers.podman
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;With our repository in place and our GitHub PAT set, the next steps
involve creating our Red Hat Ansible Automation Platform resources that
will be triggered when GitHub push events happen in the App Demo
Repository.&lt;/p&gt;
&lt;h3&gt;Creating our Ansible Automation Platform Resources&lt;/h3&gt;
&lt;p&gt;Within my automation controller dashboard, I first need to create my
credential resources to ensure that when I create my new project,
workflow and job template -- they can all easily attach my App Demo PAT
credential. &lt;/p&gt;
&lt;p&gt;Within the automation controller dashboard: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Under &lt;strong&gt;Resources&lt;/strong&gt; &amp;gt; &lt;strong&gt;Credentials&lt;/strong&gt; click the blue &lt;strong&gt;Add&lt;/strong&gt; button.&lt;/li&gt;
&lt;li&gt;Provide a &lt;strong&gt;Name&lt;/strong&gt;, e.g. App Demo PAT.&lt;/li&gt;
&lt;li&gt;Select &lt;strong&gt;GitHub Personal Access Token&lt;/strong&gt; as the &lt;strong&gt;Credential Type&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Within &lt;strong&gt;Type Details&lt;/strong&gt;, add the secret using the previously generated token from GitHub.&lt;/li&gt;
&lt;li&gt;Click &lt;strong&gt;Save&lt;/strong&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Once my App Demo PAT credential is in place, I need an additional
credential to access my host that will be running the Podman container.
In my case, this is an AWS instance.&lt;/p&gt;
&lt;p&gt;In order to access this host, I will create a
new credential that stores my AWS private key.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Under &lt;strong&gt;Resources&lt;/strong&gt; &amp;gt; &lt;strong&gt;Credentials&lt;/strong&gt; click the blue &lt;strong&gt;Add&lt;/strong&gt; button.&lt;/li&gt;
&lt;li&gt;Provide a &lt;strong&gt;Name&lt;/strong&gt;, e.g. My AWS Private Key.&lt;/li&gt;
&lt;li&gt;Select &lt;strong&gt;Machine&lt;/strong&gt; as the &lt;strong&gt;Credential Type.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Within &lt;strong&gt;Type Details&lt;/strong&gt;, add the &lt;strong&gt;SSH Private Key&lt;/strong&gt; in the text area.&lt;/li&gt;
&lt;li&gt;Click &lt;strong&gt;Save&lt;/strong&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Once the credentials are in place, I need to create an inventory that
stores the details of my AWS instance.&lt;/p&gt;
&lt;p&gt;To add details of my AWS instance, I will create an inventory
file.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Under &lt;strong&gt;Resources&lt;/strong&gt; &amp;gt; &lt;strong&gt;Inventories&lt;/strong&gt; click the blue &lt;strong&gt;Add&lt;/strong&gt; &amp;gt; &lt;strong&gt;Add inventory&lt;/strong&gt; button.&lt;/li&gt;
&lt;li&gt;Provide a &lt;strong&gt;Name&lt;/strong&gt;, e.g. App Demo Inventory.&lt;/li&gt;
&lt;li&gt;Click &lt;strong&gt;Save&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Under &lt;strong&gt;Resources&lt;/strong&gt; &amp;gt; &lt;strong&gt;Inventories&lt;/strong&gt; click &lt;strong&gt;App Demo Inventory.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Click the tab labeled &lt;strong&gt;Hosts&lt;/strong&gt; and click the &lt;strong&gt;Add&lt;/strong&gt; button.&lt;/li&gt;
&lt;li&gt;Provide a &lt;strong&gt;Name&lt;/strong&gt;, e.g. App Demo Host.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Within &lt;strong&gt;Variables&lt;/strong&gt;, provide the following YAML:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;---
ansible_host:
ansible_user: ec2-user
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;With the credentials and inventory resources set, I will create my App
Demo project. The purpose of this project is to create a workflow that
contains a job template that automatically runs every time an update to
the App Demo repository takes place. &lt;/p&gt;
&lt;p&gt;This ensures that as I make changes to my Podman container settings
within my Git repository, the container_playbook.yml runs to make the
appropriate changes. &lt;/p&gt;
&lt;p&gt;Within the automation controller dashboard:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Under &lt;strong&gt;Resources&lt;/strong&gt; &amp;gt; &lt;strong&gt;Projects&lt;/strong&gt; click the blue &lt;strong&gt;Add&lt;/strong&gt; button.&lt;/li&gt;
&lt;li&gt;Provide a &lt;strong&gt;Name&lt;/strong&gt;, e.g. App Demo Project.&lt;/li&gt;
&lt;li&gt;Select &lt;strong&gt;Default&lt;/strong&gt; as the Organization.&lt;/li&gt;
&lt;li&gt;Select &lt;strong&gt;Default execution environment&lt;/strong&gt; as the &lt;strong&gt;Execution Environment.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Select &lt;strong&gt;Git&lt;/strong&gt; as the &lt;strong&gt;Source Control Credential Type.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Within &lt;strong&gt;Type Details&lt;/strong&gt;, add the &lt;strong&gt;Source Control URL&lt;/strong&gt; (your GitHub repository).&lt;/li&gt;
&lt;li&gt;Within &lt;strong&gt;Options&lt;/strong&gt;, select &lt;strong&gt;Clean&lt;/strong&gt;, &lt;strong&gt;Delete&lt;/strong&gt;, &lt;strong&gt;Update Revision on Launch.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Click &lt;strong&gt;Save&lt;/strong&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Next, create a workflow template.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Under &lt;strong&gt;Resources&lt;/strong&gt; &amp;gt;  &lt;strong&gt;Templates&lt;/strong&gt; click the blue &lt;strong&gt;Add&lt;/strong&gt;  &amp;gt;  &lt;strong&gt;Add workflow template&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Provide a &lt;strong&gt;Name&lt;/strong&gt;, e.g. App Demo Workflow.&lt;/li&gt;
&lt;li&gt;Within &lt;strong&gt;Options&lt;/strong&gt;, checkmark &lt;strong&gt;Enable Webhook&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Within &lt;strong&gt;Webhook details&lt;/strong&gt;, select &lt;strong&gt;GitHub&lt;/strong&gt; as the &lt;strong&gt;Webhook Service&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Within &lt;strong&gt;Webhook details&lt;/strong&gt;, select your GitHub PAT token previously created as the &lt;strong&gt;Webhook Credential&lt;/strong&gt;, e.g. App Demo PAT.&lt;/li&gt;
&lt;li&gt;Click &lt;strong&gt;Save&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Within the &lt;strong&gt;Please click the Start button to begin&lt;/strong&gt; window, click &lt;strong&gt;Save&lt;/strong&gt; at the top right corner.&lt;/li&gt;
&lt;li&gt;Copy the &lt;strong&gt;Webhook URL&lt;/strong&gt; and the &lt;strong&gt;Webhook Key&lt;/strong&gt; as they will be used later.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Enabling GitHub Webhooks for the App Demo Repository&lt;/h3&gt;
&lt;p&gt;With the Ansible Automation Platform workflow template created and the
GitHub repository with the required files in place, the next step is to
enable webhooks for our repository, e.g. &lt;em&gt;app_demo&lt;/em&gt;.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;At the homepage of your GitHub repository, select the &lt;strong&gt;Settings&lt;/strong&gt; tab.&lt;/li&gt;
&lt;li&gt;Within the &lt;strong&gt;Settings&lt;/strong&gt; tab, select &lt;strong&gt;Webhooks&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Within the &lt;strong&gt;Webhooks&lt;/strong&gt; section, select the &lt;strong&gt;Add webhook&lt;/strong&gt; button.&lt;/li&gt;
&lt;li&gt;Enter the &lt;strong&gt;Payload URL&lt;/strong&gt; (Webhook URL of the workflow).&lt;/li&gt;
&lt;li&gt;Change the &lt;strong&gt;Content type&lt;/strong&gt; drop down to &lt;em&gt;application/json&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Enter the &lt;strong&gt;Secret&lt;/strong&gt; (Webhook key of the workflow).&lt;/li&gt;
&lt;li&gt;Leave the defaults to use push events, and click the button &lt;strong&gt;Add webhook&lt;/strong&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;By default, GitHub verifies SSL certificates when delivering payloads.
If your automation controller SSL certificates are not signed, ensure to
disableSSL verification.&lt;/p&gt;
&lt;h3&gt;Creating the App Demo job template&lt;/h3&gt;
&lt;p&gt;The App Demo job template runs the &lt;em&gt;container_playbook.yml&lt;/em&gt; file
automatically every time an update to the Git repository takes place. &lt;/p&gt;
&lt;p&gt;To create the job template within your automation controller dashboard:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Under &lt;strong&gt;Resources&lt;/strong&gt; &amp;gt;  &lt;strong&gt;Templates&lt;/strong&gt; click the blue &lt;strong&gt;Add&lt;/strong&gt;  &amp;gt;  &lt;strong&gt;Add job template&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Provide a &lt;strong&gt;Name&lt;/strong&gt;, e.g. App Demo Job.&lt;/li&gt;
&lt;li&gt;Select &lt;strong&gt;Run&lt;/strong&gt; as the &lt;strong&gt;Job Type.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Select &lt;strong&gt;App&lt;/strong&gt; &lt;strong&gt;Demo Inventory&lt;/strong&gt; as the &lt;strong&gt;Inventory.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Select &lt;strong&gt;App Demo Project&lt;/strong&gt; as the &lt;strong&gt;Project.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Select &lt;strong&gt;Default execution environment&lt;/strong&gt; as the &lt;strong&gt;Execution Environment.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Select &lt;em&gt;container_playbook.yml&lt;/em&gt; as the &lt;strong&gt;Playbook.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Select &lt;strong&gt;Credentials&lt;/strong&gt; and select &lt;strong&gt;My AWS Private Key.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Within &lt;strong&gt;Options&lt;/strong&gt;, select &lt;strong&gt;Enable webhook&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Select &lt;strong&gt;GitHub&lt;/strong&gt; as the &lt;strong&gt;Webhook Service&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Select your GitHub PAT token previously created as the &lt;strong&gt;Webhook Credential&lt;/strong&gt;, e.g. App Demo PAT.&lt;/li&gt;
&lt;li&gt;Click &lt;strong&gt;Save&lt;/strong&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Updating the created App Demo Workflow&lt;/h3&gt;
&lt;p&gt;Previously, the App Demo workflow was created. The purpose of this
workflow is to ensure that the App Demo Project is always in sync and
that the App Demo Job runs the container playbook whenever changes are
made to the App Demo repository.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Under &lt;strong&gt;Resources&lt;/strong&gt; &amp;gt;  &lt;strong&gt;Templates&lt;/strong&gt;, select your template. e.g &lt;em&gt;App Demo Workflow.&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Within the &lt;strong&gt;Details&lt;/strong&gt; section, select the &lt;strong&gt;Visualizer&lt;/strong&gt; tab and click the green &lt;strong&gt;Start&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;For &lt;strong&gt;Node Type&lt;/strong&gt; select &lt;strong&gt;Project Sync&lt;/strong&gt; and select the appropriate project, e.g. &lt;em&gt;App Demo Project&lt;/em&gt; and click &lt;strong&gt;Save&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Hover over the &lt;strong&gt;App Demo Project&lt;/strong&gt; and select the plus "+" symbol.&lt;/li&gt;
&lt;li&gt;Within the &lt;strong&gt;Add Node&lt;/strong&gt; window, select &lt;strong&gt;On Success&lt;/strong&gt; as to when this node should be executed and click &lt;strong&gt;Next&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Select the &lt;strong&gt;App Demo Job&lt;/strong&gt; as the &lt;strong&gt;Node Type&lt;/strong&gt; and click &lt;strong&gt;Save&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Once brought back to the &lt;strong&gt;Visualizer&lt;/strong&gt;, select the &lt;strong&gt;Save&lt;/strong&gt; button at the top right corner.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Verify App Demo Setup&lt;/h3&gt;
&lt;p&gt;To test if all is working correctly, head to your host that is running
the Podman container. Once there, the following podman ps command can be
run:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;$&lt;span class="w"&gt; &lt;/span&gt;sudo&lt;span class="w"&gt; &lt;/span&gt;podman&lt;span class="w"&gt; &lt;/span&gt;ps
CONTAINER&lt;span class="w"&gt; &lt;/span&gt;ID&lt;span class="w"&gt;  &lt;/span&gt;IMAGE&lt;span class="w"&gt;  &lt;/span&gt;COMMAND&lt;span class="w"&gt;     &lt;/span&gt;CREATED&lt;span class="w"&gt;   &lt;/span&gt;STATUS&lt;span class="w"&gt;    &lt;/span&gt;PORTS&lt;span class="w"&gt;      &lt;/span&gt;NAMES
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;NOTE: The first time you run podman ps, you should have no containers
running as you haven't run the App Demo workflow.&lt;/p&gt;
&lt;p&gt;Head over to your App Demo GitHub repository and modify the
&lt;code&gt;app_demo/group_vars/all.yml&lt;/code&gt; file where you change the color: "BLUE" to
color: "YELLOW" and  git push your changes.&lt;/p&gt;
&lt;p&gt;Head over to your automation controller dashboard and you should see the
App Demo workflow running. Once complete, within your host, verify the
container has the changes made:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;$&lt;span class="w"&gt; &lt;/span&gt;ssh&lt;span class="w"&gt; &lt;/span&gt;-i&lt;span class="w"&gt; &lt;/span&gt;&amp;lt;/path/to/private-key.pem&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;ec2-user@&amp;lt;IP&amp;gt;


$&lt;span class="w"&gt; &lt;/span&gt;sudo&lt;span class="w"&gt; &lt;/span&gt;podman&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;exec&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-it&lt;span class="w"&gt; &lt;/span&gt;colors&lt;span class="w"&gt; &lt;/span&gt;env

&lt;span class="nv"&gt;PATH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/usr/local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
&lt;span class="nv"&gt;TERM&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;xterm
&lt;span class="nv"&gt;container&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;podman
&lt;span class="nv"&gt;PYTHON_VERSION&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt;.7.0
&lt;span class="nv"&gt;PYTHON_PIP_VERSION&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;18&lt;/span&gt;.0
&lt;span class="nv"&gt;LANG&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;C.UTF-8
&lt;span class="nv"&gt;GPG_KEY&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0D96DF4D4110E5C43FBFB17A2A347FA6AA65421D
&lt;span class="nv"&gt;APP_COLOR&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;YELLOW
&lt;span class="nv"&gt;tree&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;trunk
&lt;span class="nv"&gt;HOME&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/root
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Notice how the Podman container is now running and has the color
YELLOW.&lt;/p&gt;
&lt;p&gt;Going back to the App Demo repository, change the color from YELLOW to
GREEN and git push your changes.&lt;/p&gt;
&lt;p&gt;The automation controller dashboard will run the App Demo workflow and
once complete, you can re-run the same exec command from your host and
see the color has now changed to GREEN.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;$&lt;span class="w"&gt; &lt;/span&gt;ssh&lt;span class="w"&gt; &lt;/span&gt;-i&lt;span class="w"&gt; &lt;/span&gt;&amp;lt;/path/to/private-key.pem&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;ec2-user@&amp;lt;IP&amp;gt;

$&lt;span class="w"&gt; &lt;/span&gt;sudo&lt;span class="w"&gt; &lt;/span&gt;podman&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;exec&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-it&lt;span class="w"&gt; &lt;/span&gt;colors&lt;span class="w"&gt; &lt;/span&gt;env

&lt;span class="nv"&gt;PATH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/usr/local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
&lt;span class="nv"&gt;TERM&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;xterm
&lt;span class="nv"&gt;container&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;podman
&lt;span class="nv"&gt;PYTHON_VERSION&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt;.7.0
&lt;span class="nv"&gt;PYTHON_PIP_VERSION&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;18&lt;/span&gt;.0
&lt;span class="nv"&gt;LANG&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;C.UTF-8
&lt;span class="nv"&gt;GPG_KEY&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0D96DF4D4110E5C43FBFB17A2A347FA6AA65421D
&lt;span class="nv"&gt;APP_COLOR&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;GREEN
&lt;span class="nv"&gt;tree&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;trunk
&lt;span class="nv"&gt;HOME&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/root
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;The goal of this exercise was to show the power of Ansible and GitOps.
Together, they can provide key automation to your containerized
applications.&lt;/p&gt;
&lt;p&gt;While in the demo we made a simplistic color value change of our
application, but imagine we applied this for:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;patching our application because of a security threat.&lt;/li&gt;
&lt;li&gt;updating our application to a newer version.&lt;/li&gt;
&lt;li&gt;managing containerized applications at the edge. &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And all this doesn't even mention the inherited benefits of:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Standardizing configurations of our applications.&lt;/li&gt;
&lt;li&gt;Inheriting the benefits of version control of our configurations.&lt;/li&gt;
&lt;li&gt;Easily tracking changes of the configuration settings making fixing
    issues easier.&lt;/li&gt;
&lt;li&gt;Have one source of truth for our applications.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The use cases and abilities that both tools provide together are endless. &lt;/p&gt;</description><guid>https://ansible.com/blog/taking-automation-to-the-next-level-using-ansible-gitops-to-manage-the-lifecycle-of-a-containerized-application/</guid><pubDate>Wed, 06 Jul 2022 00:00:00 GMT</pubDate></item><item><title>Automation Savings Planner</title><link>https://ansible.com/blog/automation-savings-planner/</link><dc:creator>Roger Lopez</dc:creator><description>&lt;h2&gt;Automation Savings Planner&lt;/h2&gt;
&lt;p&gt;Enterprise organizations understand that to be leaders in their
industries, they must change the way they deliver applications, improve
their relationships with customers and gain competitive advantages.&lt;/p&gt;
&lt;p&gt;Positioning those advantages to have a positive return on investment
often starts with proper planning and automation.
But what does proper planning of your automation even look like?&lt;/p&gt;
&lt;p&gt;For some enterprises, proper planning includes reducing automation
costs. For others, it's reducing time spent to open new opportunities.&lt;/p&gt;
&lt;p&gt;With this in mind, Red Hat is excited to introduce Automation Savings
Planner, a new enhancement that puts
automation planning in the forefront within the hosted services on
&lt;em&gt;console.redhat.com&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;The Automation Savings Planner is designed to provide a one stop shop to
plan, track and analyze potential efficiency improvements and cost
savings of your automation initiatives.&lt;/p&gt;
&lt;h3&gt;How does it work?&lt;/h3&gt;
&lt;p&gt;Users can create an automation savings plan within Automation Analytics
accessible at &lt;a href="https://cloud.redhat.com"&gt;cloud.redhat.com&lt;/a&gt; by defining how long and often the work is done
manually, as well as a list of tasks needed to successfully automate
this job.&lt;/p&gt;
&lt;p&gt;Once defined, you can integrate your newly automated savings plans to
automation controller's job templates to help accurately detect if the
automation is successfully running across your infrastructure. You can
also view projected cost and time savings from automating the job over
time.&lt;/p&gt;
&lt;p&gt;With these enhancements, you get a detailed overview on how to optimize
and prioritize the various automation jobs throughout your organization,
based on time and money saved. This allows you to decide what things are
most important to automate first.&lt;/p&gt;
&lt;h3&gt;Ready to start saving? Let's get started!&lt;/h3&gt;
&lt;p&gt;The first step is to create an automation savings plan that defines the
tasks needed to complete an automation job. &lt;/p&gt;
&lt;p&gt;First in the side navigation in Automation Analytics, select the
&lt;strong&gt;Savings Planner&lt;/strong&gt; navigation item. Then, click on the blue button
labeled &lt;strong&gt;Add plan&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="ROI blog one" src="https://ansible.com/images/posts/archive/roi-blog-one.png"&gt;&lt;/p&gt;
&lt;p&gt;Within the &lt;strong&gt;Create new plan&lt;/strong&gt; section, fill out the details for the
task you want to automate. The questions include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What do you want to automate? (e.g., Provision an Apache server)&lt;/li&gt;
&lt;li&gt;What type of task is it? (e.g., Operating System)&lt;/li&gt;
&lt;li&gt;A description of your automation plan&lt;/li&gt;
&lt;li&gt;How long does the process take to complete manually? (e.g., 4 hours)&lt;/li&gt;
&lt;li&gt;How many hosts do you plan to run the automation on? (e.g., 1)&lt;/li&gt;
&lt;li&gt;How often do you plan to run the automation? (e.g., weekly)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="ROI blog two" src="https://ansible.com/images/posts/archive/roi-blog-two.png"&gt;&lt;/p&gt;
&lt;p&gt;Once you've completed the &lt;strong&gt;Details&lt;/strong&gt; section, select the blue &lt;strong&gt;Next&lt;/strong&gt;
button on the lower left pane of the window.&lt;/p&gt;
&lt;p&gt;Within the &lt;strong&gt;Tasks&lt;/strong&gt; section, list out all the tasks that are needed to
complete this plan. Write out each task and select the (+) to add it to
your &lt;strong&gt;Tasks&lt;/strong&gt; list. &lt;/p&gt;
&lt;p&gt;For example, if we were looking to successfully install an Apache web
server, we'd likely include tasks such as:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Install Apache package&lt;/li&gt;
&lt;li&gt;Start HTTPD service&lt;/li&gt;
&lt;li&gt;Enable HTTPD service&lt;/li&gt;
&lt;li&gt;Enable firewall port 80&lt;/li&gt;
&lt;li&gt;Configure VirtualHost&lt;/li&gt;
&lt;li&gt;Secure Apache web server&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="ROI blog three" src="https://ansible.com/images/posts/archive/roi-blog-three.png"&gt;&lt;/p&gt;
&lt;p&gt;Once you've completed the &lt;strong&gt;Tasks&lt;/strong&gt; section for your specific plan,
select &lt;strong&gt;Next&lt;/strong&gt;. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; These tasks are for your planning purposes, and do not
currently factor into the savings estimates provided by Automation
Analytics.&lt;/p&gt;
&lt;p&gt;Lastly, within the &lt;strong&gt;Link template&lt;/strong&gt; section, select the appropriate
template to link to this plan and click &lt;strong&gt;Save&lt;/strong&gt;. &lt;/p&gt;
&lt;p&gt;Once saved, you can view the newly created plan details. &lt;/p&gt;
&lt;p&gt;&lt;img alt="ROI blog four" src="https://ansible.com/images/posts/archive/roi-blog-four.png"&gt;&lt;/p&gt;
&lt;p&gt;In this &lt;strong&gt;Details&lt;/strong&gt; view you will find a summary of all the options
created and selected for your plan. &lt;/p&gt;
&lt;p&gt;If you notice something is amiss, you can easily make changes to your
plan using the &lt;strong&gt;Edit&lt;/strong&gt; button located at the bottom left corner of the
&lt;strong&gt;Details&lt;/strong&gt; section. &lt;/p&gt;
&lt;h3&gt;And that's it!&lt;/h3&gt;
&lt;p&gt;With this newly created plan we can use Automation Savings Planner to
share a projection of how much time and money you could save by
automating a specific job. Automation Analytics takes data from the plan
details and the associated job template to provide you with an accurate
projection of your cost savings when you complete this savings plan.&lt;/p&gt;
&lt;h3&gt;Where can I find these stats?&lt;/h3&gt;
&lt;p&gt;Simply navigate to your Automation Savings Planner page, click on the
name of an existing plan and navigate to the &lt;strong&gt;Statistics&lt;/strong&gt; tab. You can
also get to this screen by clicking the "Projected Savings" links in the
card-based list of savings plans.&lt;/p&gt;
&lt;p&gt;The statistics chart displays a projection of your monetary and time
savings based on the information you provided when creating a savings
plan. Primarily, the statistics chart subtracts the automated cost from
the manual cost of executing the plan to provide the total resources
saved through automation. The chart then displays this data by year to
show you the cumulative benefits for automating the plan over time.&lt;/p&gt;
&lt;p&gt;Click between &lt;strong&gt;Money&lt;/strong&gt; and &lt;strong&gt;Time&lt;/strong&gt; to view the different types of
savings for automating the plan. An example is shown below.&lt;/p&gt;
&lt;p&gt;&lt;img alt="ROI blog five" src="https://ansible.com/images/posts/archive/roi-blog-five.png"&gt;&lt;/p&gt;
&lt;h3&gt;How are the Money and Time values determined?&lt;/h3&gt;
&lt;p&gt;Risk-adjusted factors are used to create a 3-year model projection of
costs and savings related to automation. The objective is to provide as
accurate a representation of cost and savings as possible but understand
that actual values may differ in practice.&lt;/p&gt;
&lt;p&gt;The following information breaks down:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;where we get the data&lt;/li&gt;
&lt;li&gt;the risk-adjustment factors we use&lt;/li&gt;
&lt;li&gt;the assumptions we make&lt;/li&gt;
&lt;li&gt;the formula used to compute the values as displayed in the chart&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The cost portion of the formula includes hours spent in&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Implementation&lt;/li&gt;
&lt;li&gt;Deployment&lt;/li&gt;
&lt;li&gt;Training&lt;/li&gt;
&lt;li&gt;Other expenditures for creating, maintaining &amp;amp; running the automation&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The hours (cost of investment) are typically higher on the onset and are
greatly reduced once the automation has been created and only
maintenance is required. &lt;/p&gt;
&lt;p&gt;For the initial period (including the first year), the formula uses the
following variables for its calculation.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TIME - time for manual run on one host (in hours) multiplied by 10&lt;/li&gt;
&lt;li&gt;BufferTime -extra time for unforeseen and unaccounted delays and familiarization with requirements&lt;/li&gt;
&lt;li&gt;RISK - a 40% risk adjustment¹ is applied for unforeseen situations&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The formula for the initial period and first year is represented as
follows:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;C1 = TIME + BufferTime

C2 = C1 &lt;span class="gs"&gt;* RISK&lt;/span&gt;

&lt;span class="gs"&gt;initial cost = (C1 + C2) *&lt;/span&gt; COST

year 1 cost = (C1 + C2) * COST²
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The next two years after the first year, the formula uses the following
variables for its calculation. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TIME - time for manual run on one host (in hours) multiplied by 4&lt;/li&gt;
&lt;li&gt;RISK - a 40% risk adjustment¹ to account for unforeseen situations&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The formula for the next two years is represented as follows:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;C1 = TIME

C2 = C1 &lt;span class="gs"&gt;* RISK&lt;/span&gt;

&lt;span class="gs"&gt;year 2 cost = (C1 + C2) *&lt;/span&gt; COST²

year 3 cost = (C1 + C2) * COST²
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;With the details on how cost is calculated for the plan, let's talk about savings.&lt;/p&gt;
&lt;p&gt;The savings indicates the time and money saved as a result of automating the plan. &lt;/p&gt;
&lt;p&gt;A 50% productivity recapture rate is taken to account for the
productivity that is gained by repeated manual implementation of a task
over a period of time. Included is a -5% risk adjustment for unforeseen
situations that may arise and need to be handled.&lt;/p&gt;
&lt;p&gt;A savings growth rate of 15% year over year is used. &lt;/p&gt;
&lt;p&gt;The initial period of money savings results in $0. As such no formula
is necessary for that period. &lt;/p&gt;
&lt;p&gt;The formula to calculate savings for the initial period is shown below:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;Initial period of Savings = $0 - initialCost

The  formula used for savings for year one are:

S1 = (HOSTS &lt;span class="gs"&gt;* (TIME/60) *&lt;/span&gt; FREQUENCY)

S2 = S1 &lt;span class="gs"&gt;* RECAPTURE&lt;/span&gt;

&lt;span class="gs"&gt;S3 = S2 *&lt;/span&gt; RISK * COST²

Year One Savings = S2 - S3 - Year One Cost
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;HOSTS - number of hosts&lt;/li&gt;
&lt;li&gt;TIME - manual time in minutes&lt;/li&gt;
&lt;li&gt;FREQUENCY - yearly frequency of automation&lt;/li&gt;
&lt;li&gt;RECAPTURE - 50% productivity recapture&lt;/li&gt;
&lt;li&gt;RISK - 5% Risk Adjustment&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The formula used to capture savings for year two:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;S1 = Year One Savings &lt;span class="gs"&gt;* GROWTH&lt;/span&gt;

&lt;span class="gs"&gt;Year Two Savings = Year One Savings  + S1 - Year 2 Cost&lt;/span&gt;

&lt;span class="gs"&gt;GROWTH - 15% Growth&lt;/span&gt;

&lt;span class="gs"&gt;The formula used to capture savings for year three:&lt;/span&gt;

&lt;span class="gs"&gt;S2 = Year Two Savings *&lt;/span&gt; GROWTH

Year Three Savings = Year Two Savings + S2 -Year 2 Cost
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And there you have it! The inner workings of how money and savings are
calculated to give you the projected savings of automating tasks your
organization is currently doing manually.&lt;/p&gt;
&lt;p&gt;By using Automation Savings Planner, enterprise organizations can gain
competitive advantages and a positive return on their investments by
automating key elements of their business. This not only saves time and
money, but allows businesses to expand their automation capabilities to
deliver applications, meet expectations and improve their relationships
with their customers. &lt;/p&gt;
&lt;p&gt;¹ &lt;a href="https://www.redhat.com/rhdc/managed-files/ma-forrester-ansible-economic-impact-analyst-paper-f13019bf-201808-en_0.pdf"&gt;A Forrester Total Economic Impact™ Study&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;² Cost per hour in USD if applicable, based on display.&lt;/p&gt;</description><guid>https://ansible.com/blog/automation-savings-planner/</guid><pubDate>Mon, 14 Jun 2021 00:00:00 GMT</pubDate></item></channel></rss>