<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Ansible Collaborative (Posts by Colin McNaughton)</title><link>https://ansible.com/</link><description></description><atom:link href="https://ansible.com/authors/colin-mcnaughton.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2024 &lt;a href="mailto:website@ansible.community"&gt;Ansible Collaborative, et al&lt;/a&gt; </copyright><lastBuildDate>Tue, 19 Mar 2024 16:48:34 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Creating custom Event-Driven Ansible source plugins</title><link>https://ansible.com/blog/creating-custom-event-driven-ansible-source-plugins/</link><dc:creator>Colin McNaughton</dc:creator><description>&lt;h2&gt;Creating custom Event-Driven Ansible source plugins&lt;/h2&gt;
&lt;p&gt;We're surrounded! Our modern systems and applications are constantly
generating events. These events could be generated by service requests,
application events, health checks, etc. With the wealth of information
from event traffic surrounding everything we do, Event-Driven Ansible
allows for automated responses to incoming events.&lt;/p&gt;
&lt;p&gt;But not only are we completely engulfed in event data, we're also
enveloped by event sources. Think about your organization or even your
household for a minute and consider how many pieces of equipment or
applications are generating data that could be put to use if only you
were able to easily collect it.&lt;/p&gt;
&lt;p&gt;Event source plugins within Event-Driven Ansible act as a bridge between
Ansible and event generating applications and services. Event-Driven
Ansible already has a handful of event plugins to consume events from a
variety of sources. But what if your source plug-in isn't represented in
that list? Or what if you're a Red Hat partner who wants to connect
Event-Driven Ansible to your own solution? The good news is, developing
event source plugins for Event-Driven Ansible can be a relatively
painless endeavor.&lt;/p&gt;
&lt;h3&gt;What is a source plugin?&lt;/h3&gt;
&lt;p&gt;Event-Driven Ansible leverages rulebooks to codify the response to an
event. Rulebooks combine sources, conditions and actions. An action is
executed based on one or more conditions of an event coming from a
source. Event source plugins allow rulebooks to receive events from
things like cloud services, applications and brokers. Without an event
source, events aren't received and actions aren't taken.&lt;/p&gt;
&lt;p&gt;Event sources are Python scripts contained within an Ansible Content
Collection. Within a rulebook, event sources are called by name and
parameters included in the rulebook source configuration are passed into
the event source plugin. Within the event source plugin, routines should
be written as asynchronous to prevent blocking, allowing events to be
received and addressed as efficiently as possible across multiple event
sources. For this reason, you'll notice that all of the initial source
plugins like Kafka and webhook take advantage of the asynchronous IO
paradigm.&lt;/p&gt;
&lt;h3&gt;Source plugin guidelines&lt;/h3&gt;
&lt;p&gt;Scoping a new event source plugin should be straightforward. For that
reason, there aren't many requirements for the plugin. To get started
with plugin development, here are some guidelines for source plugins:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The source plugin &lt;strong&gt;must&lt;/strong&gt; contain a specific entry point.&lt;/li&gt;
&lt;li&gt;Each source &lt;strong&gt;must&lt;/strong&gt; have nested keys which match arguments expected by the main function.&lt;/li&gt;
&lt;li&gt;Source plugins should be documented with intended purpose, expected arguments, and a rulebook example.&lt;/li&gt;
&lt;li&gt;Event source plugins should be distributed within Collections.&lt;/li&gt;
&lt;li&gt;Python routines should be written as non-blocking or asynchronous.&lt;/li&gt;
&lt;li&gt;Source plugins should include a way to test the plugin outside of Event-Driven Ansible.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;To demonstrate some of these guidelines, I'll use an example source
plugin that I created. My source plugin is called new_records and it
watches a table within ServiceNow for new records to be created (e.g.
new incidents, problems and change requests). If you'd like to test
&lt;a href="https://github.com/cloin/snow-demo-setup/tree/main/eda"&gt;this source plugin&lt;/a&gt;
for yourself, you'll need a ServiceNow instance which you can provision
as part of the &lt;a href="https://developer.servicenow.com/dev.do"&gt;ServiceNow developer program&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Before&lt;/strong&gt; you go out and test my example
plugin, please know that this plugin is coming from a sub-par python
person, is meant to be an example and not at all endorsed or suggested
for production use. ServiceNow instances also have rate limit rules for
REST resources that you may hit by polling too often. Considering that
the event push paradigm is preferred for Event-Driven Ansible source
plugins, a better implementation of this source plugin might be to
create a ServiceNow webservice to push event details to an event
aggregator! In this scenario, our integrated application (ServiceNow)
would PUSH event details to something like JetStream or Kafka (for which
there is already an event source plugin!).&lt;/p&gt;
&lt;h3&gt;The source plugin must contain a specific entry point.&lt;/h3&gt;
&lt;p&gt;A source plugin requires a pretty specific entrypoint configuration.
This entrypoint represents a function within the Python script that will
be called by ansible-rulebook, the component of Event-Driven Ansible
responsible for executing rulebooks. Let's take a look at the very
beginning of my custom source plugin for ServiceNow:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;asyncio&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;time&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;typing&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Any&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Dict&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;aiohttp&lt;/span&gt;

&lt;span class="c1"&gt;# Entrypoint from ansible-rulebook&lt;/span&gt;
&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;asyncio&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Queue&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Dict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Any&lt;/span&gt;&lt;span class="p"&gt;]):&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;After all of the import statements at the beginning of my plugin, you
can see the entrypoint is an asynchronous function called main, which
accepts two arguments. The first argument is an asyncio queue that will
be consumed by ansible-rulebook as this source is used within a
rulebook. The second argument creates a dictionary of arguments that my
particular source plugin requires to make a connection to my ServiceNow
instance. This dictionary will include things like username, password
and URL for my ServiceNow instance. That's really all that's expected as
far as the entrypoint is concerned. &lt;/p&gt;
&lt;h3&gt;Each source must have nested keys which match arguments expected by the main function.&lt;/h3&gt;
&lt;p&gt;This is a slightly more complicated way of saying that the arguments I
require within my custom ServiceNow event plugin should also be keys
within the rulebook used to configure the source plugin. To demonstrate
this, look at the source configuration for my custom plugin within a
rulebook and then look at the arguments expected by the main function
that ansible-rulebook executes:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Rulebook example:&lt;/em&gt;&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;-&lt;/span&gt; name: Watch for new records
  hosts: localhost
  sources:
    &lt;span class="k"&gt;-&lt;/span&gt; cloin.servicenow.new_records:
            instance: https://dev-012345.service-now.com
            username: ansible
            password: ansible
            table: incident
            interval: 1
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Plugin code:&lt;/em&gt;&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Entrypoint&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;from&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ansible&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;rulebook&lt;/span&gt;
&lt;span class="n"&gt;async&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;def&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nl"&gt;queue&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;asyncio&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Queue&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nl"&gt;args&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Dict&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;str, Any&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;instance&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;"instance"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;username&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;"username"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;password&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;"password"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nc"&gt;table&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;"table"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;"query"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;"sys_created_onONToday@javascript:gs.beginningOfToday()@javascript:gs.endOfToday()"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;interval&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;"interval"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;As a note, if you're worried about distributing rulebooks with
credentials or other sensitive arguments, &lt;code&gt;ansible-rulebook&lt;/code&gt; also
accepts variables set in vars files or from environment variables
using &lt;code&gt;--vars&lt;/code&gt; or &lt;code&gt;--env-vars&lt;/code&gt; respectively. This would mean
that your rulebook source configuration
could look more like:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="x"&gt;- name: Watch for new records&lt;/span&gt;
&lt;span class="x"&gt;  hosts: localhost&lt;/span&gt;
&lt;span class="x"&gt;  sources:&lt;/span&gt;
&lt;span class="x"&gt;    - cloin.servicenow.new_records:&lt;/span&gt;
&lt;span class="x"&gt;        instance: &lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;SN_HOST&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;
&lt;span class="x"&gt;        username: &lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;SN_USERNAME&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;
&lt;span class="x"&gt;        password: &lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;SN_PASSWORD&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;
&lt;span class="x"&gt;        table: incident&lt;/span&gt;
&lt;span class="x"&gt;        interval: 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;Source plugins should be documented with purpose, expected arguments, and a rulebook example.&lt;/h3&gt;
&lt;p&gt;This is sort of a no-brainer that even I, an incredibly sub-par Python
developer, can get on board with. In fact, this is actually one of my
New Year's resolutions for 2023. Take a look at the top of my source
plugin as an example:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="sd"&gt;"""&lt;/span&gt;
&lt;span class="sd"&gt;new_records.py&lt;/span&gt;

&lt;span class="sd"&gt;Description:&lt;/span&gt;
&lt;span class="sd"&gt;event-driven-ansible source plugin example&lt;/span&gt;
&lt;span class="sd"&gt;Poll ServiceNow API for new records in a table&lt;/span&gt;
&lt;span class="sd"&gt;Only retrieves records created after the script began executing&lt;/span&gt;
&lt;span class="sd"&gt;This script can be tested outside of ansible-rulebook by specifying&lt;/span&gt;
&lt;span class="sd"&gt;environment variables for SN_HOST, SN_USERNAME, SN_PASSWORD, SN_TABLE&lt;/span&gt;

&lt;span class="sd"&gt;Arguments:&lt;/span&gt;
&lt;span class="sd"&gt;  - instance: ServiceNow instance (e.g. https://dev-012345.service-now.com)&lt;/span&gt;
&lt;span class="sd"&gt;  - username: ServiceNow username&lt;/span&gt;
&lt;span class="sd"&gt;  - password: ServiceNow password&lt;/span&gt;
&lt;span class="sd"&gt;  - table:  Table to watch for new records&lt;/span&gt;
&lt;span class="sd"&gt;  - query:  (optional) Records to query. Defaults to records created today&lt;/span&gt;
&lt;span class="sd"&gt;  - interval: (optional) How often to poll for new records. Defaults to 5 seconds&lt;/span&gt;

&lt;span class="sd"&gt;Usage in a rulebook:&lt;/span&gt;
&lt;span class="sd"&gt;- name: Watch for new records&lt;/span&gt;
&lt;span class="sd"&gt;  hosts: localhost&lt;/span&gt;
&lt;span class="sd"&gt;  sources:&lt;/span&gt;
&lt;span class="sd"&gt;    - cloin.servicenow.new_records:&lt;/span&gt;
&lt;span class="sd"&gt;            instance: https://dev-012345.service-now.com&lt;/span&gt;
&lt;span class="sd"&gt;            username: ansible&lt;/span&gt;
&lt;span class="sd"&gt;            password: ansible&lt;/span&gt;
&lt;span class="sd"&gt;            table: incident&lt;/span&gt;
&lt;span class="sd"&gt;            interval: 1&lt;/span&gt;
&lt;span class="sd"&gt;  rules:&lt;/span&gt;
&lt;span class="sd"&gt;    - name: New record created&lt;/span&gt;
&lt;span class="sd"&gt;      condition: event.sys_id is defined&lt;/span&gt;
&lt;span class="sd"&gt;      action:&lt;/span&gt;
&lt;span class="sd"&gt;            debug:&lt;/span&gt;
&lt;span class="sd"&gt;"""&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Fair enough of a guideline, right? The documentation pretty clearly lays
out that this is an Event-Driven Ansible plugin, what the plugin can be
expected to do, the arguments the plugin accepts and how to use this
plugin within a rulebook. &lt;/p&gt;
&lt;h3&gt;Event source plugins should be distributed within Collections.&lt;/h3&gt;
&lt;p&gt;Ansible Content Collections represent the model by which Ansible content
can be easily distributed. Typically, these Collections contain things
like plugins, roles, playbooks and documentation, and demonstrate
Ansible's extensibility. Event source plugins and rulebooks become just
additional content types that can be distributed by way of Ansible
Content Collections. This is demonstrated in my plugin documentation
here:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;-&lt;/span&gt; name: Watch for new records
  hosts: localhost
  sources:
    &lt;span class="k"&gt;-&lt;/span&gt; cloin.servicenow.new_records:
            instance: https://dev-012345.service-now.com
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;Python routines should be written as non-blocking or asynchronous.&lt;/h3&gt;
&lt;p&gt;The asynchronous model says that, for example, requests against the
ServiceNow API by the new_records source plugin shouldn't block or slow
down requests to another API by another source plugin. By using asyncio
along with async and await within the plugin, we simply pause that one
routine and await a result instead of blocking other routines from
executing. If you combine two source plugins written to utilize only
synchronous routines into the same rulebook, you could find that your
rulebook executes slowly or reacts to events long after they occurred.
Here's an example from my source plugin:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;            async with session.get(f'{instance}/api/now/table/{table}?sysparm_query={query}', auth=auth) as resp:
                if resp.status == 200:

                    records = await resp.json()
                    for record in records['result']:
…
                      await queue.put(record)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Note the keywords &lt;strong&gt;async&lt;/strong&gt; and &lt;strong&gt;await&lt;/strong&gt;. The &lt;strong&gt;async&lt;/strong&gt; keyword lets
Python know that this coroutine will be executed asynchronously within
an event loop while waiting on the result from whatever has been
"awaited" designated by the &lt;strong&gt;await&lt;/strong&gt; keyword, in this case, the
response from the ServiceNow API call.&lt;/p&gt;
&lt;p&gt;Another line worth mentioning is the final &lt;strong&gt;await&lt;/strong&gt; in the above
snippet of &lt;strong&gt;queue.put(record)&lt;/strong&gt;. This is an essential line as this is
how the record can be consumed by the rulebook engine. By putting the
record returned by the ServiceNow API onto the queue, we're able to
execute actions defined in the rulebook  based on the record returned by
the API request.&lt;/p&gt;
&lt;h3&gt;Source plugins should include a way to test the plugin outside of Event-Driven Ansible.&lt;/h3&gt;
&lt;p&gt;This one really isn't a hard and fast rule for creating source plugins.
I'd say it's more helpful in the plugin development process and may more
resemble a best practice or general tip than anything else. By including
a function that only runs when the script is called directly by running,
for example: python new_records.py, you're able to quickly test changes
to the script without first setting up a rulebook and starting
ansible-rulebook. For my sample plugin, I use the following:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="gh"&gt;#&lt;/span&gt; this is only called when testing plugin directly, without ansible-rulebook
if __name__ == "__main__":
    instance = os.environ.get('SN_HOST')
    username = os.environ.get('SN_USERNAME')
    password = os.environ.get('SN_PASSWORD')
    table   = os.environ.get('SN_TABLE')

    class MockQueue:
        async def put(self, event):
            print(event)

    asyncio.run(main(MockQueue(), {"instance": instance, "username": username, "password": password, "table": table}))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;If you take a look at that code example, you can see a comment that this
is really just for testing the Python script directly. If you want to
test this code yourself, you can define the four environment variables
(e.g. export SN_TABLE=incident...) and then execute the script. From
there, open up your ServiceNow instance and create a new record in the
table you're watching (in the case of SN_TABLE=incident,  you'd want to
create a new incident) and see that the script prints out the newly
created record.&lt;/p&gt;</description><guid>https://ansible.com/blog/creating-custom-event-driven-ansible-source-plugins/</guid><pubDate>Tue, 07 Feb 2023 00:00:00 GMT</pubDate></item><item><title>Find and delete ServiceNow records en masse with the updated Ansible Content Collection</title><link>https://ansible.com/blog/find-and-delete-servicenow-records-en-masse-with-the-updated-ansible-content-collection/</link><dc:creator>Colin McNaughton</dc:creator><description>&lt;h2&gt;Find and delete ServiceNow records en masse with the updated Ansible Content Collection&lt;/h2&gt;
&lt;p&gt;Have you ever had to query and remove a long list of ServiceNow records?
Yeah, neither have I until recently. Nobody broke into my instance, and
this isn't a one-time operation, I just happen to maintain an instance
that we use to test our Red Hat Ansible Certified Content Collection
for ServiceNow ITSM. &lt;/p&gt;
&lt;p&gt;To set up the environment, I use a demo system and another workflow to
create a random user and then allow a learner to progress through some
challenges using full Red Hat Ansible Automation Platform deployments
and a shared ServiceNow instance. Because this is a real live instance,
there's no telling what sort of records learners will create. For this
reason, I recently had to develop some automation to clean up records
created by these demo user accounts.&lt;/p&gt;
&lt;p&gt;Although my use-case was to clean up demo user accounts, this could just
as well have been a critical ServiceNow instance that had erroneous
records that needed cleaning up. This Collection can be leveraged to
create, update, modify, or delete just about anything on ServiceNow.&lt;/p&gt;
&lt;p&gt;If you're following along, make sure you install a version of the
servicenow.itsm Collection equal to or greater than 2.0.0 (Community on
&lt;a href="https://galaxy.ansible.com/servicenow/itsm"&gt;Ansible Galaxy&lt;/a&gt; |
Certified on &lt;a href="https://console.redhat.com/ansible/automation-hub/servicenow/itsm"&gt;Ansible automation
hub&lt;/a&gt;).&lt;/p&gt;
&lt;h3&gt;How did I do it?&lt;/h3&gt;
&lt;h4&gt;Using sys_tags&lt;/h4&gt;
&lt;p&gt;I have a tag setup in ServiceNow that gets applied to everything these
demo users create. I like this approach because tag creation and
auto-application of tags is something that can be limited to accounts
with elevated permissions. The tag is applied to any records created by
users as a part of my hands-on lab, and helps me to locate and clean up
anything those particular users created. First, I need to grab the
sys_id (this is like a global ID of a particular record) of the tag. For
this, I leverage the API module shipped in the servicenow.itsm
Collection against ServiceNow's label table:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="x"&gt;- name: Find tag ID by name&lt;/span&gt;
&lt;span class="x"&gt;  servicenow.itsm.api_info:&lt;/span&gt;
&lt;span class="x"&gt;    resource: label&lt;/span&gt;
&lt;span class="x"&gt;    sysparm_query: name=&lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;tag_name&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;
&lt;span class="x"&gt;      columns:&lt;/span&gt;
&lt;span class="x"&gt;        - name&lt;/span&gt;
&lt;span class="x"&gt;        - sys_id&lt;/span&gt;
&lt;span class="x"&gt;  register: tag_info&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Once I have located the appropriate tag by name, I can query the
incident table for active records that have that tag applied:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="x"&gt;- name: Get tagged incidents&lt;/span&gt;
&lt;span class="x"&gt;  servicenow.itsm.incident_info:&lt;/span&gt;
&lt;span class="x"&gt;    sysparm_query:&lt;/span&gt;
&lt;span class="x"&gt;    sys_tags.&lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;tag_info.record&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="nv"&gt;.sys_id&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="x"&gt;=&lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;tag_info.record&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="nv"&gt;.sys_id&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;
&lt;span class="x"&gt;    ^active=true&lt;/span&gt;
&lt;span class="x"&gt;    sysparm_display_value: false&lt;/span&gt;
&lt;span class="x"&gt;  register: incidents&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;What's&lt;/em&gt; sysparm_display_value&lt;em&gt;?&lt;/em&gt; Fair enough, good question. This
parameter instructs my query to return the actual values, and not the
display values. Display values vary depending on the type of field, and,
in this case, sys_tags does not include the name of the tag returned by
the query. Setting this parameter to false means that this query returns
the actual value. &lt;/p&gt;
&lt;p&gt;After querying all active records in the incident table that have that
tag applied and registering the output as a variable called incidents, I
wanted to simplify things by creating an array of objects that contain
incident numbers and the date/time they were opened:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="x"&gt;- name: query incident number and creation time&lt;/span&gt;
&lt;span class="x"&gt;  ansible.builtin.set_fact:&lt;/span&gt;
&lt;span class="x"&gt;    incident_list: '&lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;incident_list&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="o"&gt;[{&lt;/span&gt;&lt;span class="s2"&gt;"number"&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nv"&gt;item.number&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"opened_at"&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nv"&gt;item.opened_at&lt;/span&gt;&lt;span class="o"&gt;}]&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="x"&gt;'&lt;/span&gt;
&lt;span class="x"&gt;  loop: "&lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;incidents.json.result&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="x"&gt;"&lt;/span&gt;
&lt;span class="x"&gt;  when: incidents&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Each object in the array should look something like:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;-&lt;/span&gt; number: INC00001234
  opened_at: 2022-04-26 18:34:16
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;For my use case, having the time the record was created is super useful.
I don't really want to destroy records that were created less than two
hours ago. After all, I don't want to remove records in use by learners
progressing through my challenges.&lt;/p&gt;
&lt;p&gt;The last task is to take my list of incidents, and remove them if
they're over two hours old. For this, I use the
servicenow.itsm.incident module and some conditional check against the
record creation time:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="x"&gt;- name: close old incidents from list&lt;/span&gt;
&lt;span class="x"&gt;  servicenow.itsm.incident:&lt;/span&gt;
&lt;span class="x"&gt;    state: closed&lt;/span&gt;
&lt;span class="x"&gt;    number: "&lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;item.number&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="x"&gt;"&lt;/span&gt;
&lt;span class="x"&gt;    close_code: "Solved (Permanently)"&lt;/span&gt;
&lt;span class="x"&gt;    close_notes: "Closed with ansible servicenow.itsm"&lt;/span&gt;
&lt;span class="x"&gt;  loop: "&lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;incident_list&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="x"&gt;"&lt;/span&gt;
&lt;span class="x"&gt;  when:&lt;/span&gt;
&lt;span class="x"&gt;    - incident_list is defined&lt;/span&gt;
&lt;span class="x"&gt;    - (( (ansible_date_time.date + ' ' + ansible_date_time.time) | to_datetime) - (item.opened_at | to_datetime)).total_seconds() &amp;gt; 7200&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;See that second line under&lt;/strong&gt; &lt;strong&gt;when?&lt;/strong&gt; It's not super pretty, but
it's basically making sure that the two time formats are the same
before trying to evaluate the difference in seconds between the two
dates. The first date/time is current execution time, the second
date/time is the time the record was created. If the difference is
greater than two hours (7200 seconds), then the condition is true, the
task continues and the record is closed.&lt;/p&gt;
&lt;h4&gt;Without using sys_tags&lt;/h4&gt;
&lt;p&gt;What if I didn't have tags automatically applied to all of these
records? In that case, I can query records by other keys using
&lt;code&gt;servicenow.itsm.*_info&lt;/code&gt; modules. For instance, I can query and close
all active incident records created by a specific user:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="x"&gt;- name: find user created incidents&lt;/span&gt;
&lt;span class="x"&gt;  servicenow.itsm.incident_info:&lt;/span&gt;
&lt;span class="x"&gt;    query:&lt;/span&gt;
&lt;span class="x"&gt;        - sys_created_by: = &lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;username&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;
&lt;span class="x"&gt;        active: = true&lt;/span&gt;
&lt;span class="x"&gt;  register: incidents&lt;/span&gt;

&lt;span class="x"&gt;- name: query incident number and creation time&lt;/span&gt;
&lt;span class="x"&gt;  ansible.builtin.set_fact:&lt;/span&gt;
&lt;span class="x"&gt;    incident_list: '&lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;incident_list&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="o"&gt;[{&lt;/span&gt;&lt;span class="s2"&gt;"number"&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nv"&gt;item.number&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"opened_at"&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nv"&gt;item.opened_at&lt;/span&gt;&lt;span class="o"&gt;}]&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="x"&gt;'&lt;/span&gt;
&lt;span class="x"&gt;  loop: "&lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;incidents.records&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="x"&gt;"&lt;/span&gt;
&lt;span class="x"&gt;  when: incidents&lt;/span&gt;

&lt;span class="x"&gt;- name: close incidents from list&lt;/span&gt;
&lt;span class="x"&gt;  servicenow.itsm.incident:&lt;/span&gt;
&lt;span class="x"&gt;    state: closed&lt;/span&gt;
&lt;span class="x"&gt;    number: "&lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;item.number&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="x"&gt;"&lt;/span&gt;
&lt;span class="x"&gt;    close_code: "Solved (Permanently)"&lt;/span&gt;
&lt;span class="x"&gt;    close_notes: "Closed with ansible servicenow.itsm"&lt;/span&gt;
&lt;span class="x"&gt;    other:&lt;/span&gt;
&lt;span class="x"&gt;      active: false&lt;/span&gt;
&lt;span class="x"&gt;  loop: "&lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;incident_list&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="x"&gt;"&lt;/span&gt;
&lt;span class="x"&gt;  when:&lt;/span&gt;
&lt;span class="x"&gt;    - incident_list is defined&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;Completing the picture&lt;/h3&gt;
&lt;p&gt;I have tasks that do similar things for different record types like
problems, change requests, etc., but they all follow the same pattern as
tasks shown above. I arrange these tasks in a workflow within automation
controller that executes each day to keep this ServiceNow instance tidy.&lt;/p&gt;
&lt;p&gt;The 2.0.0 release of servicenow.itsm made all of these tasks much easier
by introducing performance improvements and new API modules to perform
operations on arbitrary tables. For instance, perhaps you'd like to
attach a role to a user. That is super easy by leveraging the API module
against the sys_user_has_role table:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="x"&gt;- name: attach role to new user&lt;/span&gt;
&lt;span class="x"&gt;  servicenow.itsm.api:&lt;/span&gt;
&lt;span class="x"&gt;    resource: sys_user_has_role&lt;/span&gt;
&lt;span class="x"&gt;    action: post&lt;/span&gt;
&lt;span class="x"&gt;    data:&lt;/span&gt;
&lt;span class="x"&gt;      user: "&lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;username&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="x"&gt;"&lt;/span&gt;
&lt;span class="x"&gt;      role: "&lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;role&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="x"&gt;"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Boom!&lt;/p&gt;
&lt;p&gt;This is probably a non-standard operation. Why would you normally need
to destroy or close out records in your organization's source of truth?
I'm not sure! What I do know is that extending your organization's
automation strategy to other mainstay ITSM processes is made so much
easier by leveraging Ansible Automation Platform and the Red Hat Ansible
Certified Content Collection for ServiceNow ITSM.&lt;/p&gt;
&lt;h3&gt;Anything else?&lt;/h3&gt;
&lt;p&gt;Yeah! Did you know there is a place to get hands-on experience with
Ansible Automation Platform right
&lt;a href="https://www.redhat.com/en/engage/redhat-ansible-automation-202108061218"&gt;HERE&lt;/a&gt;?
That is where you'll find my ServiceNow automation challenges that walk
through the functionality of the Collection I leverage to keep my
instance tidy and CMDB up to date.&lt;/p&gt;</description><guid>https://ansible.com/blog/find-and-delete-servicenow-records-en-masse-with-the-updated-ansible-content-collection/</guid><pubDate>Mon, 07 Nov 2022 00:00:00 GMT</pubDate></item><item><title>Automation content navigator releases with Ansible Automation Platform 2.2</title><link>https://ansible.com/blog/released-automation-content-navigator-2.0/</link><dc:creator>Colin McNaughton</dc:creator><description>&lt;h2&gt;Automation content navigator releases with Ansible Automation Platform 2.2&lt;/h2&gt;
&lt;h3&gt;What is it?&lt;/h3&gt;
&lt;p&gt;Automation content navigator was released alongside Red Hat Ansible
Automation Platform 2.0 and changed the way content creators build and
test Ansible automation. Navigator 1.0 drew together multiple Ansible
command line tools like ansible-playbook, ansible-doc, ansible-config,
etc. and continues to accrue seriously useful new features to help
deliver greater flexibility to automation creators.&lt;/p&gt;
&lt;p&gt;Coinciding with the release of Ansible Automation Platform 2.2,
navigator 2.0 introduces improvements to existing functionality
alongside additional features to aid in the development of automation
content.&lt;/p&gt;
&lt;p&gt;Within navigator 2.0, you will find:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Automation execution environment image build support &lt;/li&gt;
&lt;li&gt;Ability to interact in real-time with automation execution
    environments &lt;/li&gt;
&lt;li&gt;Settings subcommand to view active configuration of local
    environment &lt;/li&gt;
&lt;li&gt;Generate a sample configuration file that can be used for new
    projects&lt;/li&gt;
&lt;li&gt;Automatic mode selection (stdout vs. interactive) &lt;/li&gt;
&lt;li&gt;Technology preview lint support, UI improvements, Collections view
    support for Ansible built-ins, time zone support, color
    enhancements, and more!&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Looking closer&lt;/h3&gt;
&lt;h4&gt;Image builder support&lt;/h4&gt;
&lt;p&gt;Before the release of navigator 2.0, a separate command line application
(ansible-builder)  was needed to build execution environment images from
human readable YAML files. With this release, ansible-navigator installs
ansible-builder and includes a new build command that is used to pass
through arguments to ansible-builder allowing content creators to create
images from a single familiar interface.&lt;/p&gt;
&lt;h4&gt;Why should I care?&lt;/h4&gt;
&lt;p&gt;All enhancements to ansible-builder can be leveraged from
ansible-navigator. This functionality helps to cement navigator's role
within the content creators workflow to allow not only content creation
and environment introspection, but also execution environment build
support from within navigator.&lt;/p&gt;
&lt;h4&gt;Things to try:&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Add the arista.avd Collection to the supported execution
    environment:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;==&amp;gt; ./builder/execution-environment.yml&lt;/em&gt;&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="o"&gt;---&lt;/span&gt;
&lt;span class="nl"&gt;version:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;
&lt;span class="nl"&gt;build_arg_defaults:&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nl"&gt;EE_BASE_IMAGE:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"registry.redhat.io/ansible-automation-platform-21/ee-supported-rhel8:latest"&lt;/span&gt;
&lt;span class="nl"&gt;dependencies:&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nl"&gt;galaxy:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;requirements&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;yml&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nl"&gt;system:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;""&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nl"&gt;python:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;""&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;==&amp;gt; ./builder/requirements.yml&lt;/em&gt;&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;---
collections:
  - arista.avd
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;$&lt;span class="w"&gt; &lt;/span&gt;ansible-navigator&lt;span class="w"&gt; &lt;/span&gt;builder&lt;span class="w"&gt; &lt;/span&gt;build&lt;span class="w"&gt; &lt;/span&gt;--workdir&lt;span class="w"&gt; &lt;/span&gt;builder
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;Introducing the exec command&lt;/h3&gt;
&lt;p&gt;With a new subcommand, exec, automation creators now have the ability to
open a shell in the default execution environment. This allows creators
to further inspect the execution environment and leverage utilities
installed within the execution environment without installing them on a
local workstation.&lt;/p&gt;
&lt;p&gt;For example, imagine you're creating some new workflows and you need to
leverage an additional Collection from Ansible automation hub. Instead
of installing the ansible-galaxy command-line tool on the local
workstation, you can run a command within navigator to install the
Collection in a directory alongside the new workflows. Because the
current working directory is bind mounted to the running container, the
installed Collection is placed on the local filesystem.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;ansible-navigator&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;exec&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;--&lt;span class="w"&gt; &lt;/span&gt;ansible-galaxy&lt;span class="w"&gt; &lt;/span&gt;collection&lt;span class="w"&gt; &lt;/span&gt;install&lt;span class="w"&gt; &lt;/span&gt;servicenow.itsm&lt;span class="w"&gt; &lt;/span&gt;-p&lt;span class="w"&gt; &lt;/span&gt;./collections
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;After running the above command, a new directory called "Collections"
should exist in your current working directory (CWD). This directory
will be made available to the execution environment at runtime because
the CWD is bind mounted at runtime. This allows you to always tell which
Collections are installed within the execution environment and which
have been bind mounted to the container.&lt;/p&gt;
&lt;h4&gt;Why should I care?&lt;/h4&gt;
&lt;p&gt;Navigator lowers the barrier for creating new content! A creator now
only needs to install ansible-navigator to begin creating new
automation. Leveraging execution environments, the content creator
doesn't even need to install ansible-core! Navigator pulls in a default
execution environment that contains ansible-core and common Ansible
command line utilities such as ansible-galaxy. The exec command allows
these to be leveraged from within the default execution environment
instead of relying on workstation configuration.&lt;/p&gt;
&lt;h4&gt;Things to try:&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Encrypt a secret using a vault password file:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;$&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;secret_vault_password&lt;span class="w"&gt; &lt;/span&gt;&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;password_file
$&lt;span class="w"&gt; &lt;/span&gt;ansible-navigator&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;exec&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;--&lt;span class="w"&gt; &lt;/span&gt;ansible-vault&lt;span class="w"&gt; &lt;/span&gt;encrypt_string&lt;span class="w"&gt; &lt;/span&gt;--vault-password-file&lt;span class="w"&gt; &lt;/span&gt;password_file&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;'secret'&lt;/span&gt;
!vault&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="nv"&gt;$ANSIBLE_VAULT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;.1&lt;span class="p"&gt;;&lt;/span&gt;AES256
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="m"&gt;64323039613737313538666239363032396361613464393033343165663631653835356232373139&lt;/span&gt;

Encryption&lt;span class="w"&gt; &lt;/span&gt;successful
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;Scaffold a new Collection in the CWD, in the playbook adjacent
    Collection directory:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;$&lt;span class="w"&gt; &lt;/span&gt;ansible-navigator&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;exec&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;--&lt;span class="w"&gt; &lt;/span&gt;env
&lt;span class="nv"&gt;ANSIBLE_CACHE_PLUGIN&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;jsonfile
&lt;span class="nv"&gt;DESCRIPTION&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;Red&lt;span class="w"&gt; &lt;/span&gt;Hat&lt;span class="w"&gt; &lt;/span&gt;Ansible&lt;span class="w"&gt; &lt;/span&gt;Automation&lt;span class="w"&gt; &lt;/span&gt;Platform&lt;span class="w"&gt; &lt;/span&gt;Minimal&lt;span class="w"&gt; &lt;/span&gt;Execution&lt;span class="w"&gt; &lt;/span&gt;Environment
&lt;span class="nv"&gt;SSH_AUTH_SOCK&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/run/user/1000/keyring/ssh
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;Navigator settings command&lt;/h3&gt;
&lt;p&gt;The settings command surfaces the configuration of the local environment
from within navigator. From the settings screen, creators are able to
view default values and values changed by local configuration
parameters. Leveraging this within an integrated development environment
(IDE) such as VS Code is especially helpful using features like
command+click to open a file path within the editor. For example, a
creator is able to see that a local ansible.cfg or ansible-navigator.yml
file is being sourced by navigator and can open that file within the
configured editor directly from the navigator settings screen.&lt;/p&gt;
&lt;h4&gt;Why should I care?&lt;/h4&gt;
&lt;p&gt;Ansible is flexible! System-wide configuration files can be sourced for
multiple automation projects. It's very helpful to the content creator
to be able to view default configuration, which configuration parameters
have been defined in local configuration files and which files are being
sourced by the current project. All of this enhances a streamlined
creator workflow that becomes more predictable for content creators.&lt;/p&gt;
&lt;h4&gt;Navigator sample settings&lt;/h4&gt;
&lt;p&gt;Imagine you are an automation content creator starting a new project.
You know that this new project will:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;use a newly built execution environment&lt;/li&gt;
&lt;li&gt;require navigator to have reasonable configuration defaults&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In addition, you know you want to customize navigator to use your
preferred code editor.&lt;/p&gt;
&lt;p&gt;Navigator sample settings allow creators to display a sample
ansible-navigator.yml configuration file with all parameters commented
out. This allows the creator to pick and choose which settings to adjust
for the new project. Things like default execution environment image
name, image pull policy, which code editor to use when opening files
from navigator, etc. are all configured from ansible-navigator.yml.
Additionally, this sample settings file can be written to the local
filesystem where, once edited for the new project, can be sourced by
navigator.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;$&lt;span class="w"&gt; &lt;/span&gt;ansible-navigator&lt;span class="w"&gt; &lt;/span&gt;settings&lt;span class="w"&gt; &lt;/span&gt;--sample&lt;span class="w"&gt; &lt;/span&gt;&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;my.yaml
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;Why should I care?&lt;/h4&gt;
&lt;p&gt;Multiple automation projects usually mean multiple execution
environments that need to be defined as the default execution
environment for the corresponding project. By allowing settings files to
be created from navigator, creators do not need to rely on memory to
define the parameters necessary to customize and deploy their projects.&lt;/p&gt;
&lt;h4&gt;Things to try:&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Use the TUI to review the current settings:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;$&lt;span class="w"&gt; &lt;/span&gt;ansible-navigator&lt;span class="w"&gt; &lt;/span&gt;settings
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;Review the effective setting for ansible-navigator:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;$&lt;span class="w"&gt; &lt;/span&gt;ansible-navigator&lt;span class="w"&gt; &lt;/span&gt;settings&lt;span class="w"&gt; &lt;/span&gt;--effective
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;Show the source for each of the current settings:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;$&lt;span class="w"&gt; &lt;/span&gt;ansible-navigator&lt;span class="w"&gt; &lt;/span&gt;settings&lt;span class="w"&gt; &lt;/span&gt;--sources
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;Automatic mode selection&lt;/h3&gt;
&lt;p&gt;Navigator consists of a textual user interface (TUI) that operates in
interactive mode by default. In interactive mode, creators run commands
and navigate the interface by using a series of keystrokes. Navigator
1.0 supported standard out mode for some commands. This means that
instead of opening up the full interactive user interface, creators
could run commands and query information about the local environment
without opening up the TUI. Standard out mode is helpful, for instance,
in CI/CD pipelines where there is no need to run commands interactively.&lt;/p&gt;
&lt;p&gt;With navigator 2.0, more commands are supported in standard out mode.
For example, the collections subcommand can now run in standard out mode
and interactive mode. It's very useful to automation creators to see
which Collections are available in the environment to figure out which
modules can be leveraged in automated workflows.&lt;/p&gt;
&lt;p&gt;Additionally, navigator now supports automatic mode selection for
commands that are only offered in a single mode. Previously the &lt;code&gt;--mode&lt;/code&gt;
command line argument was necessary for commands that only supported
mode stdout.&lt;/p&gt;
&lt;h4&gt;Why should I care?&lt;/h4&gt;
&lt;p&gt;Navigator is easily adapted to individual creators' workflows and
preferences. Even more, by adding standard out support for more
commands, navigator can now be utilized in automated build environments.&lt;/p&gt;
&lt;h4&gt;Things to try:&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Show the help for the ansible-playbook command without specifying
    &lt;code&gt;--mode stodut&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;$&lt;span class="w"&gt; &lt;/span&gt;ansible-navigator&lt;span class="w"&gt; &lt;/span&gt;run&lt;span class="w"&gt; &lt;/span&gt;--help-playbook
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;Show the help for the ansible-builder command:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;$&lt;span class="w"&gt; &lt;/span&gt;ansible-navigator&lt;span class="w"&gt; &lt;/span&gt;builder&lt;span class="w"&gt; &lt;/span&gt;--help-builder
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;Lint functionality (technology preview)&lt;/h3&gt;
&lt;p&gt;One very nice use of interactive mode is in the newly added and
experimental feature for linting Ansible content. The lint subcommand,
when coupled with a path to an Ansible Playbook or directory of Ansible
content, opens a new screen in navigator where problems and suggestions
are displayed for the file(s) passed into the lint command. As the
problem files are corrected and saved, the list of problems and
suggestions shrinks. Coupled with a code editor's ability to
control+click to open a file path, editing files with potential issues
is quick and fits in well with the rest of the creator experience.&lt;/p&gt;
&lt;h4&gt;Why should I care?&lt;/h4&gt;
&lt;p&gt;Consistent content produces reliable automation. Lint support allows
creators the ability to ensure that the content produced adheres to best
practices.&lt;/p&gt;
&lt;h4&gt;Things to try:&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Lint a playbook using the latest creator execution environment&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;$&lt;span class="w"&gt; &lt;/span&gt;ansible-navigator&lt;span class="w"&gt; &lt;/span&gt;lint&lt;span class="w"&gt; &lt;/span&gt;site.yaml&lt;span class="w"&gt; &lt;/span&gt;--eei&lt;span class="w"&gt; &lt;/span&gt;quay.io/ansible/creator-ee:latest
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;What now?&lt;/h3&gt;
&lt;p&gt;Automation content navigator 2.0 is available for use today! Navigator
offers improvements to the authoring and testing experience. As a
result, automation content creators have more tools on hand to assist in
the creation and maintenance of automated workflows. &lt;/p&gt;</description><guid>https://ansible.com/blog/released-automation-content-navigator-2.0/</guid><pubDate>Wed, 01 Jun 2022 00:00:00 GMT</pubDate></item><item><title>Using Ansible Automation Platform, GitLab CE and webhooks to deploy IIS website</title><link>https://ansible.com/blog/using-ansible-automation-platform-gitlab-ce-and-webhooks-to-deploy-iis-website/</link><dc:creator>Colin McNaughton</dc:creator><description>&lt;h2&gt;Using Ansible Automation Platform, GitLab CE and webhooks to deploy IIS website&lt;/h2&gt;
&lt;p&gt;Inside Red Hat Ansible Automation Platform, the Ansible Tower REST API
is the key mechanism that helps enable automation to be integrated into
processes or tools that exist in an environment. With Ansible Tower 3.6
we have brought direct integration with webhooks from GitHub and GitLab,
including the enterprise on-premises versions. This means that changes
in source control can trigger automation to apply changes to
infrastructure configuration, deploy new services, reconfigure existing
applications, and more. In this blog, I'll run through a simple scenario
and apply the new integrated webhook feature.&lt;/p&gt;
&lt;h2&gt;Environment&lt;/h2&gt;
&lt;p&gt;My environment consists of Ansible Tower (one component of Red Hat
Ansible Automation Platform), GitLab CE with a project already created,
and a code server running an IDE with the same git repository cloned. A
single inventory exists on Ansible Tower with just one host, an instance
of Windows 2019 Server running on a certified cloud. For this example,
I'm going to deploy IIS on top of this Windows server and make some
modifications to the html file that I'd like to serve from this site. &lt;/p&gt;
&lt;p&gt;My playbook to deploy IIS is &lt;em&gt;very&lt;/em&gt; simple:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt; ---
&lt;span class="k"&gt;-&lt;/span&gt; name: Configure IIS
  hosts: windows

  tasks:
  &lt;span class="k"&gt;-&lt;/span&gt; name: Install IIS
    win_feature:
      name: Web-Server
      state: present

  &lt;span class="k"&gt;-&lt;/span&gt; name: Start IIS service
    win_service:
      name: W3Svc
      state: started

  &lt;span class="k"&gt;-&lt;/span&gt; name: Create website index.html
    win_copy:
      src: files/web.html
      dest: C:\Inetpub\wwwroot\index.html
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;All that I am doing here is adding the &lt;code&gt;Web-Server&lt;/code&gt; feature, starting
IIS and copying my site's html file to the default location for web
content being served by IIS. &lt;/p&gt;
&lt;p&gt;My html file is just as basic:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;html&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;title&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;title&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;body&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;

&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;body&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;html&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;Objective and setup&lt;/h3&gt;
&lt;p&gt;What I would like to happen is that, for each merge request that makes
changes to this one IIS site, the site should be redeployed with this
basic html file.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Colin blog new one" src="https://ansible.com/images/posts/archive/colin-blog-new-one.png"&gt;&lt;/p&gt;
&lt;h3&gt;GitLab Access Token&lt;/h3&gt;
&lt;p&gt;As my webhook is triggered, I would like to update the merge request
created in GitLab with the status of my Ansible Tower job. &lt;/p&gt;
&lt;p&gt;To accomplish this, I first have to create a personal access token for
my GitLab account so that Ansible Tower can access the GitLab API. This
is pretty painless. All I have to do is navigate to my user settings and
select "Access Tokens" from the left side navigation panel:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Colin blog two" src="https://ansible.com/images/posts/archive/colin-blog-two.png"&gt;&lt;/p&gt;
&lt;p&gt;I give my access token an easily recognizable name of "Ansible Tower,"
set the expiration date to the end of the month, and scope this access
token to just the API. Upon clicking "Create personal access token," the
token itself becomes visible and a new entry is shown at the bottom of
this page:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Colin blog three" src="https://ansible.com/images/posts/archive/colin-blog-three.png"&gt;&lt;/p&gt;
&lt;p&gt;Next, I will use this token to create a new credential in Ansible Tower
of type "GitLab Personal Access Token":&lt;/p&gt;
&lt;p&gt;&lt;img alt="Colin blog four" src="https://ansible.com/images/posts/archive/colin-blog-four.png"&gt;&lt;/p&gt;
&lt;p&gt;Upon saving, Ansible Tower now has API access to my GitLab account. &lt;/p&gt;
&lt;h3&gt;Ansible Tower Job Template&lt;/h3&gt;
&lt;p&gt;Now that Ansible Tower has the ability to update my merge requests, I
need to configure webhook access to my job template that is configured
to run my simple IIS playbook. Since the Ansible Tower 3.6 release,
there is now a checkbox on each job template called &lt;strong&gt;ENABLE WEBHOOK&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="coling blog new three" src="https://ansible.com/images/posts/archive/colin-blog-new-three.png"&gt;&lt;/p&gt;
&lt;p&gt;Once I select the option to &lt;strong&gt;ENABLE WEBHOOK&lt;/strong&gt; I am presented with a few
new fields. I select GitLab as my &lt;strong&gt;WEBHOOK SERVICE&lt;/strong&gt;, supply the
credential I created using my GitLab personal access token, &lt;strong&gt;WEBHOOK
URL&lt;/strong&gt; is prepopulated with the path to this job template and, upon
saving my modifications, a &lt;strong&gt;WEBHOOK KEY&lt;/strong&gt; is generated which I will use
to configure the project hook in GitLab. Also, note that my project
allows me to override the SCM branch. This means that the project will
pull updates from the "change-web-text" branch instead of Master. &lt;/p&gt;
&lt;h3&gt;GitLab Project Hook integration&lt;/h3&gt;
&lt;p&gt;The next step takes me back to GitLab, this time navigating to the
integrations page of the project I would like to execute the webhook.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Colin blog six" src="https://ansible.com/images/posts/archive/colin-blog-six.png"&gt;&lt;/p&gt;
&lt;p&gt;On the integrations page, I supply the URL (&lt;strong&gt;WEBHOOK URL&lt;/strong&gt; from my job
template in Ansible Tower) and Secret Token (&lt;strong&gt;WEBHOOK KEY&lt;/strong&gt; from my job
template in Ansible Tower). I also specify the Trigger as "Merge request
events" which means that the URL I specified will be launched anytime a
merge request is opened.&lt;/p&gt;
&lt;p&gt;&lt;img alt="colin blog new two" src="https://ansible.com/images/posts/archive/colin-blog-new-two.png"&gt;&lt;/p&gt;
&lt;h3&gt;In action: Updating my website text&lt;/h3&gt;
&lt;p&gt;Now that I've given Ansible Tower access to my projects using a personal
access token as a new credential type, configured my job template to
enable webhooks, and configured a Project Hook on GitLab to respond to
merge request events on my project, I'm ready to make a test commit of
my html file.&lt;/p&gt;
&lt;p&gt;Here, I add text to the &lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; tags of my html
document and save the file:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Colin blog eight" src="https://ansible.com/images/posts/archive/colin-blog-eight.png"&gt;&lt;/p&gt;
&lt;p&gt;Once I've committed my change on my "change-web-text" branch, I will
push my code, go back to GitLab and open a merge request to merge
changes back into master.&lt;/p&gt;
&lt;p&gt;&lt;img alt="colin new blog" src="https://ansible.com/images/posts/archive/colin-new-blog.png"&gt;&lt;/p&gt;
&lt;p&gt;Opening this merge request will now trigger my webhook which will deploy
my web page changes to my IIS site. Because I have configured Ansible
Tower with my personal access token, Ansible Tower will post a link to
the job executed as a result of the webhook trigger on the merge
request.&lt;/p&gt;
&lt;p&gt;If all has been configured correctly, I should see a new job being
executed that corresponds to the job template with the configured
webhook. I should also see a job that has been kicked off, updating my
project which will pull in the latest changes from my GitLab project.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Colin blog nine" src="https://ansible.com/images/posts/archive/colin-blog-nine.png"&gt;&lt;/p&gt;
&lt;p&gt;Selecting the job for "iis website create", which is the job template I
configured for webhook execution, shows that the job was &lt;strong&gt;LAUNCHED BY&lt;/strong&gt;
webhook. &lt;strong&gt;EXTRA VARIABLES&lt;/strong&gt; will show a lot of project specific
configuration facts, and more importantly the job output should show
that the job is executing what it's supposed to.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Colin blog ten" src="https://ansible.com/images/posts/archive/colin-blog-ten.png"&gt;&lt;/p&gt;
&lt;p&gt;Upon completion, I should be able to pull up the IP of my IIS server and
see the changes to my incredible html page:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Colin blog eleven" src="https://ansible.com/images/posts/archive/colin-blog-eleven.png"&gt;&lt;/p&gt;
&lt;h3&gt;Takeaways&lt;/h3&gt;
&lt;p&gt;Webhooks introduced in Ansible Tower 3.6 are an incredibly powerful way
to launch automation in response to events in source control. While this
basic website is just a very quick and simple example, applying this
functionality to infrastructure as code where all service configurations
are defined in Ansible Playbooks greatly emphasizes this robust feature.&lt;/p&gt;</description><guid>https://ansible.com/blog/using-ansible-automation-platform-gitlab-ce-and-webhooks-to-deploy-iis-website/</guid><pubDate>Tue, 17 Mar 2020 00:00:00 GMT</pubDate></item><item><title>Getting Started With Ansible Content Collections</title><link>https://ansible.com/blog/getting-started-with-ansible-collections/</link><dc:creator>Colin McNaughton</dc:creator><description>&lt;h2&gt;Getting Started With Ansible Content Collections&lt;/h2&gt;
&lt;p&gt;With the release of Red Hat Ansible Automation Platform, Ansible Content
Collections are now fully supported. Ansible Content Collections, or
collections, represent the new standard of distributing, maintaining and
consuming automation. By combining multiple types of Ansible content
(playbooks, roles, modules, and plugins), flexibility and scalability
are greatly improved.&lt;/p&gt;
&lt;h3&gt;Who Benefits?&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Everyone!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Traditionally, module creators have had to wait for their modules to be
marked for inclusion in an upcoming Ansible release or had to add them
to roles, which made consumption and management more difficult. By
shipping modules within Ansible Content Collections along with pertinent
roles and documentation, and removing the barrier to entry, creators are
now able to move as fast as the demand for their creations. For a public
cloud provider, this means new functionality of an existing service or a
new service altogether, can be rolled out along with the ability to
automate the new functionality.&lt;/p&gt;
&lt;p&gt;For the automation consumer, this means that fresh content is
continuously made available for consumption. Managing content in this
manner also becomes easier as modules, plugins, roles, and docs are
packaged and tagged with a collection version. Modules can be updated,
renamed, improved upon; roles can be updated to reflect changes in
module interaction; docs can be regenerated to reflect the edits and all
are packaged and tagged together. &lt;/p&gt;
&lt;p&gt;On top of this, before collections, it was not uncommon for modules to
break or lack timely updates needed to interact with the services they
were interfacing with. This often required Ansible users or Ansible
Tower administrators to run multiple versions of Ansible in &lt;a href="https://docs.ansible.com/ansible-tower/latest/html/administration/tipsandtricks.html#using-virtualenv-with-at"&gt;virtual
environments&lt;/a&gt;
in order to consume a patch that addressed a module issue. Ansible
Content Collections bring stability and predictability by breaking
modules out from the core distribution.&lt;/p&gt;
&lt;p&gt;For automated organizations, this means that certified content is
readily available to be applied to use-cases ripe for automation from
day one.&lt;/p&gt;
&lt;h3&gt;Where to Find Collections&lt;/h3&gt;
&lt;p&gt;With the launch of Red Hat Ansible Automation Platform, Automation Hub
will be the source for certified collections. Additionally, collections
creators can also package and distribute content on Ansible Galaxy.
Ultimately, it is up to the creator to decide the delivery mechanism for
their content, with Automation Hub being the only source for Red Hat
Certified Collections.&lt;/p&gt;
&lt;h3&gt;A Closer Look at Collections&lt;/h3&gt;
&lt;p&gt;An Ansible Content Collection can be described as a package format for
Ansible content:&lt;/p&gt;
&lt;p&gt;&lt;img alt="example collection filesystem" src="https://ansible.com/images/posts/archive/example-collection-filesystem.png"&gt;&lt;/p&gt;
&lt;p&gt;This format has a simple, predictable data structure, with a
straightforward definition:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;docs/&lt;/code&gt;: local documentation for the collection&lt;/li&gt;
&lt;li&gt;&lt;code&gt;galaxy.yml&lt;/code&gt;: source data for the MANIFEST.json that will be part of
    the collection package&lt;/li&gt;
&lt;li&gt;&lt;code&gt;playbooks/&lt;/code&gt;: playbooks reside here &lt;ul&gt;
&lt;li&gt;&lt;code&gt;tasks/&lt;/code&gt;: this holds 'task list files' for &lt;code&gt;include_tasks/import_tasks&lt;/code&gt; usage&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;plugins/&lt;/code&gt;: all ansible plugins and modules go here, each in its own subdir&lt;ul&gt;
&lt;li&gt;&lt;code&gt;modules/&lt;/code&gt;: ansible modules&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lookups/&lt;/code&gt;: &lt;a href="https://docs.ansible.com/ansible/latest/plugins/lookup.html"&gt;lookup plugins&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;filters/&lt;/code&gt;: &lt;a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html"&gt;Jinja2 filter plugins&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;connection/&lt;/code&gt;: &lt;a href="https://docs.ansible.com/ansible/latest/plugins/connection.html"&gt;connection plugins&lt;/a&gt;
    required if not using default&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;roles/&lt;/code&gt;: directory for ansible roles&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tests/&lt;/code&gt;: tests for the collection's content&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="https://docs.ansible.com/ansible/latest/dev_guide/collections_galaxy_meta.html"&gt;More information regarding collection
metadata&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Interacting with Collections&lt;/h3&gt;
&lt;p&gt;In addition to downloading collections through the browser, the
&lt;code&gt;ansible-galaxy&lt;/code&gt; command line utility has been updated to manage
collections, providing much of the same functionality as has always been
present to manage, create and consume roles. For example,
&lt;code&gt;ansible-galaxy collection init&lt;/code&gt; can be used to create a starting
point for a new user created collection.&lt;/p&gt;
&lt;p&gt;&lt;img alt="galaxy collection init example" src="https://ansible.com/images/posts/archive/init-galaxy-collection.gif"&gt;&lt;/p&gt;
&lt;p&gt;Along with the correct directory structure to start creating a
collection from, this command also generates a metadata file that will
be used while building the collection with namespace and collection name
pre-populated:&lt;/p&gt;
&lt;p&gt;&lt;img alt="example galaxy metadata" src="https://ansible.com/images/posts/archive/example-collection-galaxy.png"&gt;&lt;/p&gt;
&lt;h3&gt;Where to Go Next&lt;/h3&gt;
&lt;p&gt;Ansible Content Collections were first introduced as tech preview in
Ansible Engine 2.8 and are now fully supported in Ansible Engine 2.9 and
are an integral part of Red Hat Ansible Automation Platform. Collections
allow Red Hat Ansible Automation Platform to offer certified, stable
content in order to continue expanding use cases for automation. Future
posts will dive deeper into developing new collections and converting
existing roles into collections.&lt;/p&gt;</description><guid>https://ansible.com/blog/getting-started-with-ansible-collections/</guid><pubDate>Thu, 14 Nov 2019 00:00:00 GMT</pubDate></item></channel></rss>